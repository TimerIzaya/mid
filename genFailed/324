const v2 = new Uint8ClampedArray(80);
const v5 = new Float32Array(1024);
new BigUint64Array(104);
function F9(a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.b = Uint8ClampedArray;
    } catch(e14) {
    }
}
const v15 = new F9(F9, 1024, 80);
const v16 = new F9(Uint8ClampedArray, 104, 104);
new F9(v16, 1024, 80);
class C18 extends Float32Array {
    1;
    n(a20, a21) {
        v15[9] = 80;
        let v22 = 0;
        do {
            v2.byteOffset >>>= v22;
            v2[v22] = v16;
            this["fill"](v5, a20, 104);
            v22++;
        } while (v22 < 4)
        return Float32Array;
    }
}
new C18();
new C18();
new C18();
function f31() {
    return Uint8ClampedArray;
}
for (let v32 = 0; v32 < 65; v32++) {
    const v34 = Symbol.iterator;
    const o43 = {
        [v34]() {
            let v36 = 10;
            const o42 = {
                next() {
                    v36--;
                    const v40 = v36 == 0;
                    const o41 = {
                        "done": v40,
                        "value": v36,
                    };
                    return o41;
                },
            };
            return o42;
        },
    };
}
