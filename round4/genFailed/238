try {
    new Float32Array(1024);
} catch(e3) {
}
try {
    new Int8Array(1280);
} catch(e7) {
}
let v8 = 2130;
try {
    new BigUint64Array(v8);
} catch(e11) {
}
class C12 {
    static [1280] = Float32Array;
    get b() {
        try {
            super.f **= -1538461947;
        } catch(e17) {
        }
        return v8;
    }
    #e = 1280;
    static [Float32Array] = v8;
    d;
    f;
}
const v18 = new C12();
const v19 = new C12();
let v20 = new C12();
function F21(a23, a24, a25) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.f = v8;
    } catch(e26) {
    }
    try {
        this.d = a24;
    } catch(e27) {
    }
    try {
        this.h = v19;
    } catch(e28) {
    }
}
const v29 = new F21(1280, 1280, 1024);
new F21(1280, v8, 1280);
new F21(v8, 1024, 1280);
class C32 extends Float32Array {
    #valueOf(a34, a35, a36) {
        try {
            v20 |= C12;
        } catch(e37) {
        }
        try {
            Int8Array ** a36;
        } catch(e39) {
        }
        return F21;
    }
    f;
    static #f = v29;
    e = 1280;
    6;
}
new C32();
new C32();
new C32();
switch (v18) {
    case Int8Array:
        try {
            v29[7] &= 1024;
        } catch(e43) {
        }
        break;
}
try { C32(); } catch (e) {}
try {
    v8 = 1024;
} catch(e45) {
}
