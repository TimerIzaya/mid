let v1 = -9007199254740992;
class C3 {
    constructor(a5) {
        super[-3];
        a5 = -4294967297;
    }
    static #n(a8, a9) {
        [611717.8535227415];
        [NaN,-2.952294496744534e+307,1.6140295459231194e+308];
        return [6.436253375238734e+307,-994320.6272445577,-9.595754285794067,-5.0,NaN,-1.350705031012275e+308,903524.141795221];
    }
}
const v16 = new C3(-4294967297);
const v17 = new C3(v1);
const v18 = new C3(-3);
const v20 = [v17,[v16,-4294967297],v17,v17];
[v20,v16,v20,v17];
const v23 = new Map();
const v25 = new Map(C3 = v18);
v23.size;
for (const v27 of v25) {
}
v1 = -4294967297;
const v0 = [2.2250738585072014e-308];
const v1 = [7.85426330865567e+307,-9.910292620995572e+306];
const v2 = [3.0];
function F6(a8, a9) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.b = 247471134;
    } catch(e10) {
    }
    try {
        this.d = a9;
    } catch(e11) {
    }
}
const v12 = new F6(v2, v2);
const v13 = new F6(v0, v0);
let v14 = new F6(v0, v2);
const v15 = [196858697,7,1963439341,-8,1000,5];
const v16 = [64,-13,16,0,7,-1,-4,65535];
const v17 = [7,1632986441,303310671,-256,-4096];
class C18 {
    get f() {
        v1 / v2;
        try {
            v1.concat(-2147483648, undefined);
        } catch(e25) {
        }
        return v16;
    }
    static #g;
    static g;
    static #a;
    static b = v16;
}
const v26 = new C18();
let v27 = new C18();
const v28 = new C18();
try { v28.m(v13, v26, v15, v13, v0); } catch (e) {}
++v27;
try {
    try {
        C18[v12] = v28;
    } catch(e31) {
    }
} catch(e32) {
    Math.acos(v14);
    const v36 = --v14;
    v14 >>> v14;
    ~v36 ** 2147483649;
} finally {
    try {
        v17[10] = v16;
    } catch(e40) {
    }
}
