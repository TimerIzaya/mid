class C3 {
    static set g(a5) {
        try { a5(...a5, this, ..."9J9tb", ...-4); } catch (e) {}
        const o9 = {
            "maxByteLength": 1610191554,
        };
        const v11 = new ArrayBuffer(9, o9);
        new Uint32Array(v11);
    }
    static #f = -1073741824;
}
const v14 = new C3();
const v15 = new C3();
const v16 = new C3();
function f17(a18, a19, a20) {
    const o31 = {
        [a19](a22, a23, a24, a25) {
            this >> a24;
            try { v14.p(); } catch (e) {}
            [127];
            [5,693956592];
            [-12675,-726393087,-6,-25813,129];
            return -4;
        },
        "d": v14,
        "c": a18,
        "a": a20,
        "e": a19,
        "f": v15,
    };
    return o31;
}
const v32 = f17(v14, v15, "9J9tb");
f17(v32, v32, v16);
const v34 = f17("9J9tb", v14, C3);
const v37 = new Float32Array(0);
new Uint8Array(5);
const v43 = new Int16Array(1567);
Int16Array | v32;
Object.defineProperty(v15, "f", { writable: true, enumerable: true, set: f17 });
const o48 = {
    ..."9J9tb",
    "c": v37,
    "h": v43,
    "g": v34,
};
try {
    new Int32Array(2);
} catch(e3) {
}
try {
    new Int8Array(5);
} catch(e7) {
}
try {
    new Int32Array(23);
} catch(e11) {
}
function F12(a14, a15, a16, a17) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.a = a14;
    } catch(e18) {
    }
}
const v19 = new F12(5, 2, 5, 5);
const v20 = new F12(5, 2, 23, 23);
const v21 = new F12(23, 5, 2, 23);
class C22 {
    static n(a24, a25, a26) {
        return 2n;
    }
    constructor(a31, a32, a33, a34) {
        for (let v35 = 0; v35 < 32; v35++) {
            v21["p" + v35] = v35;
        }
    }
}
const v38 = new C22(C22, 23, F12, 23);
new C22(v38, 2, v21, 2);
const v40 = new C22(v20, 23, v19, 2);
throw v40;
const v41 = v38[7];
const v42 = [v40,v41,v38];
[C22,v41,[Int8Array]];
try {
    v42.g = v41;
} catch(e45) {
}
let v49 = 10000 >>> 10000;
(10000 % v49--) << v19;
