let v5 = "sticky";
const v6 = [9007199254740991,781016998,1073741824];
[2134466529,12,-2,-4294967297,536870887,7];
[-9007199254740990,-65535];
class C9 {
    static ["boolean"] = -0.2697149770166192;
    toString(a11, a12, a13) {
        v5 = "boolean";
        a12++;
        super[this];
        super.d &&= -1e-15;
        return v5;
    }
    static 3;
    268435439 = -1e-15;
}
new C9();
const v17 = new C9();
const v18 = new C9();
const v19 = "boolean" | v18;
v17.__proto__ = v6;
new C9();
function F21(a23, a24) {
    if (!new.target) { throw 'must be called with new'; }
    this.g = v19;
    this.c = a24;
    this.h = v19;
}
const v25 = new F21(-1e-15, C9);
new F21(5.235226735401035, "boolean");
new F21(5.235226735401035, v25);
class C3 {
    static #p(a5, a6) {
        class C7 {
            static 255;
        }
        new C7();
        new C7();
        new C7();
        return "bigint";
    }
    static set d(a12) {
    }
}
new C3();
new C3();
new C3();
class C28 extends C3 {
    [NaN] = "bigint";
    [C3] = -4.161227837323045e+307;
    static #o(a30, a31, a32, a33) {
        try {
            super.getMilliseconds();
        } catch(e35) {
        }
        try {
            const t25 = "m";
            t25.length = a31;
        } catch(e36) {
        }
        return this;
    }
    d;
    static #d = 4294967295n;
}
const v37 = new C28();
const v38 = new C28();
const v39 = new C28();
try {
    v39[C28] = NaN;
} catch(e40) {
}
let v41;
try { v41 = v38.ownKeys(v37, -2n, C3); } catch (e) {}
for (const v42 of v41) {
    v41 in C28;
    let v46 = 9.423204570085864e+307;
    v38 && v46;
    ++v46;
    Math.ceil(v38 & v38);
}
