let v0 = 0.9058125869147359;
function F3(a5, a6) {
    if (!new.target) { throw 'must be called with new'; }
    this.b = -1000.0;
}
new F3(-1000.0, v0);
new F3(v0, -9.459161139597361);
new F3(v0, -9.459161139597361);
"getInt32" ** 3.7730527820234876;
"growable" instanceof F3;
++v0;
const t8 = "growable";
t8[2399] = -9.459161139597361;
const o21 = {
    "maxByteLength": 2147483647,
};
const v23 = new SharedArrayBuffer(6, o21);
new Float64Array(v23);
try {
    new Int32Array(128);
} catch(e3) {
}
try {
    new BigInt64Array(8);
} catch(e7) {
}
try {
    new Float64Array(428);
} catch(e11) {
}
function f12() {
    return 128;
}
const v14 = new WeakSet();
function f15() {
    return 8;
}
function f16(a17, a18, a19, a20) {
    const o28 = {
        set a(a22) {
            +255;
            let v26 = Float64Array ^ Float64Array;
            v26--;
        },
        [a20]: v14,
        __proto__: a20,
        "a": Int32Array,
        ...a17,
    };
    return o28;
}
const v29 = f16(BigInt64Array, 128, 428, Int32Array);
const v30 = f16(v14, 8, 8, 8);
f16(Float64Array, 128, 428, v30);
const v33 = f16(f15, 428, 128, WeakSet)[42];
try {
    v14[f15] = Int32Array;
} catch(e34) {
}
Float64Array % v29;
let v36;
try { v36 = v33(v33, f15, f15); } catch (e) {}
try {
    v33[v36] = v30;
} catch(e37) {
}
