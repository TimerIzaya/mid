[0.5292239614152447,1000000.0,0.45824067008100156,2.53412911077939e+307,-1e-15,8.12081740130737,-284.24401855427277,-8.854169282930381e+307,-4.0,1e-15];
const v1 = [0.6542160476277123,899.9514389858602,-245842.00223119825,105.83502285002965,0.8941302200830888];
[-9.61250559759047,-9.34619964409091,1.3137709839146664e+308,6.795920037710391e+307,732.5186125676737,NaN,1e-15,-1000000.0,0.9232394326878188];
new Uint32Array(710);
new Int16Array(8);
new Int16Array(92);
function f12() {
    return Uint32Array;
}
for (let [v13,v14,v15] of v1) {
    function F16(a18, a19, a20) {
        if (!new.target) { throw 'must be called with new'; }
        this.e = a20;
        this.b = a20;
    }
    const v21 = new F16(Uint32Array, f12, v15);
    new F16(v21, Int16Array, 710);
    new F16(92, v13, v14);
}
class C3 {
    a = -9007199254740990n;
    #e;
    #d = -9223372036854775808n;
    #m(a5, a6) {
        [2147483648,-60864,4,8385,-9007199254740990];
        [0,42204,6];
        [1440071496,-4294967296,-9223372036854775808,-5332,-4294967297];
        try { new a6(-9223372036854775808n, this); } catch (e) {}
        return this;
    }
    static #b = 0n;
    [-9007199254740990n];
    static 411 = -9223372036854775808n;
    static [0n] = -9223372036854775808n;
}
const v11 = new C3();
const v12 = new C3();
new C3();
let v15 = 30203;
try {
    new BigUint64Array(3864);
} catch(e23) {
}
try {
    new BigInt64Array(0);
} catch(e27) {
}
try {
    new BigUint64Array(9);
} catch(e31) {
}
v12 << 12592;
v12[-61023];
try {
    v15 |= 0;
} catch(e34) {
}
let v39 = -2147483647;
let v40 = v39++;
const v41 = 4n ^ 4n;
Math.sign(4n);
!v41;
Math.asinh(v11);
++v39;
v40++;
