const v0 = [13,-2,-52688,4096,-11,-1289239302,825627929,-223093247,10,3];
const v1 = [9,-2147483647,65536,2147483648,-9007199254740990,-268435456,8,1073741825];
const v2 = [-4294967295,-346934382];
class C3 {
    [C3] = C3;
    a;
    static f = C3;
    [v2] = v0;
    1000;
    static {
        const v5 = v0.length;
        let v6;
        try { v6 = new v1(v2, v5, v0); } catch (e) {}
        v1[4] = v6;
    }
    f = v1;
    static #c = v2;
    constructor(a8, a9) {
        a9[0];
        try {
            v0.#c %= v2;
        } catch(e11) {
        }
    }
}
const v12 = new C3(v0, v1);
let v13 = new C3(v0, v1);
const v14 = new C3(v1, v0);
function F15(a17, a18, a19) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.a = v1;
    } catch(e20) {
    }
    try {
        this.b = a19;
    } catch(e21) {
    }
}
function f22(a23) {
    ({"f":v13,} = v12);
    try {
        v2[a23] = v1;
    } catch(e24) {
    }
    return a23;
}
F15[Symbol.toPrimitive] = f22;
const v27 = new F15(v13, v12, v0);
const v28 = new F15(v14, v27, C3);
new F15(C3, v14, v28);
class C30 {
    m(a32, a33) {
        try {
            super.b = v28;
        } catch(e34) {
        }
        return v27;
    }
    [F15];
    #d = v12;
    static [v14] = v2;
    static [v0];
    #e;
}
new C30();
const v36 = new C30();
v36.e;
v2.length;
[0.9674972542734839,0.39405752160412943,-3.0];
[1000000000.0,5.0,8.991090103224754e+307];
[-1.388648497762192e+308,-1e-15,-4.0,7.325162462580536,70.40361888559983,-1.634222282362603e+308];
new C30();
const v43 = [512,1000,-11,1930083367,-20405];
v43.constructor = Symbol;
class C46 {
}
C46[Symbol.isConcatSpreadable] = C30;
v43.concat(2147483647, 638507719, C46);
