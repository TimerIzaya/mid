class C3 {
    #n(a5, a6) {
        let v7;
        try { v7 = a5.o(0.343854193852403, 0.0, a6, a5, -10); } catch (e) {}
        for (let v8 = 0; v8 < 32; v8++) {
            a5["p" + v8] = v8;
        }
        return v7;
    }
    [0.343854193852403];
    static #b;
    static 4294967296;
    [0.0];
}
const v11 = new C3(0.0, 0.0, C3);
const v12 = new C3();
const v13 = new v11();
class C14 extends C3 {
    constructor(a16, a17, a18) {
        super();
        v13.a;
        Math.tan(1188195176);
        function F23(a25, a26, a27) {
            if (!new.target) { throw 'must be called with new'; }
            const v28 = this.constructor;
            try { new v28(this); } catch (e) {}
            a25[5];
            a26 ^ a26;
        }
        [315.62665971106094,1e-15,-1.0,0.9826412952633506,NaN,-1.7976931348623157e+308,0.6514427199918571,0.24903044111605677,1000000.0];
        [-1e-15,-177.5200500778824,-547.4045005435148,5.0,0.7628320045821202,1.7976931348623157e+308,-145853.52694223647,524.0507402455266,-916.7101087717233];
        [3.0,601.8851596956181,1.0];
    }
    static [v13] = -10;
    static set g(a36) {
        function f38(a39, a40, a41) {
            const o42 = {
                5: 5n,
            };
            o42[5];
            o42[5];
            return 5n;
        }
        %OptimizeFunctionOnNextCall(f38);
        %VerifyType(-10);
        try { this(this); } catch (e) {}
    }
    static #h;
}
const v46 = new C14(C3, C3, v12);
const v47 = new C14(C3, v46, v12, 0.0, v46);
new C14(v13, v13, v13);
class C49 {
    h;
    [C14];
    #b = 0.343854193852403;
    static o(a51, a52, a53, a54) {
        try {
            this[3] = v11;
        } catch(e55) {
        }
        return a53;
    }
    [v13] = C14;
    static #f;
    10000 = v47;
}
new C49();
new C49(v12, C49, C14);
new C49();
class C59 {
}
const o64 = {
    set f(a61) {
    },
    set d(a63) {
    },
};
const v65 = new C59();
const v66 = new C59();
C59[v65] = v66;
C59[4294967296] = C59;
