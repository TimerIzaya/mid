class C4 extends Date {
    constructor(a6, a7, a8, a9) {
        super("boolean");
    }
}
new C4();
try {
    new Int32Array(7);
} catch(e12) {
}
([9,-28731,14,-38721,16,-9,-17788,-2,4294967297]).toSpliced;
function F15(a17, a18, a19) {
    if (!new.target) { throw 'must be called with new'; }
}
class C21 extends BigUint64Array {
}
Math.exp(255);
class C28 {
    static g;
    static [65536] = "g";
    static b;
    static #b;
    static #f;
}
try {
    new BigInt64Array(255);
} catch(e30) {
}
try {
    new BigInt64Array(1315);
} catch(e34) {
}
let v35 = 1919218961;
class C41 extends BigInt64Array {
    p(a43, a44, a45, a46) {
        try {
            class C47 {
                static h;
                static {
                }
            }
            v35 &&= 255;
        } catch(e55) {
        }
        return Int32Array;
    }
    1 = 1.0;
    static #toString(a57, a58, a59, a60) {
        delete this[1894767853];
        for (let v62 = 0; v62 < 32; v62++) {
            this["p" + v62] = v62;
        }
        return -3.0;
    }
    constructor(a66) {
        const o67 = {
        };
    }
    static #p(a69, a70, a71, a72) {
    }
}
new C41();
new C41();
new C41();
function f76() {
}
f76();
const v78 = f76();
function F82(a84, a85, a86) {
    if (!new.target) { throw 'must be called with new'; }
    const v87 = this.constructor;
    try { new v87(); } catch (e) {}
    new Int16Array(4096);
    const v93 = new Int16Array(1315);
    v93.includes(-3.0);
    const t74 = [];
    t74[16] |= 16;
    new Uint16Array();
    new Uint32Array();
}
new F82();
new F82(v78, -4096);
