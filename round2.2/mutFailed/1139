class C3 {
    static f;
    #m(a5) {
        this ^ a5;
        return this;
    }
    static p(a11) {
        this[277327095];
        function f13(a14) {
            return C3;
        }
        class C15 extends -9007199254740992n {
            181 = -9007199254740992n;
            static [-9007199254740992n];
        }
        return f13;
    }
}
const t18 = -9007199254740992n;
const v16 = new t18();
const v17 = v16?.constructor;
try { new v17(); } catch (e) {}
const v19 = new C3();
try { v19.constructor(); } catch (e) {}
const v21 = new C3();
v16?.constructor;
try { new v21(); } catch (e) {}
class C24 {
    static m(a26, a27, a28, a29) {
        try { v19.valueOf(a28); } catch (e) {}
        Math.log1p(-1.5544126518189235e+308);
        (a28 || a27) || this;
        a27 - a27;
        return this;
    }
    static b;
    [C3];
}
const v38 = new C24();
new C24();
C3?.constructor;
try { new C3(); } catch (e) {}
new C24();
[65535];
[-256,-2147483648,536870912,48769];
const v45 = [536870912,-15,1,25039,-13,15,-735215864];
let v46 = 5;
v46--;
try {
    Int16Array(v46, v46);
} catch(e50) {
    e50.g = e50;
}
try {
    Uint32Array();
} catch(e54) {
}
try {
    Float32Array(8);
} catch(e58) {
    e58.e = e58;
}
function F59(a61, a62, a63, a64) {
    if (!new.target) { throw 'must be called with new'; }
    a61 >>> a61;
    a63 / a63;
    a64--;
}
const v68 = new F59(v46, 8, v46, 5);
const v69 = new F59(v46, 8, v46, 8);
const v70 = v69?.constructor;
try { new v70(C3, v21, C3, v38); } catch (e) {}
const v72 = new F59(5, 5, 5, v46);
const v73 = v72?.__lookupGetter__;
try { new v73(v19); } catch (e) {}
const v75 = [-14,60606,-16407];
const v76 = [536870889,-1];
const v77 = [-65537,65537,4294967297,-1170382801,65535,536870888,1073741825,-1];
v77[2];
class C79 {
}
try { C79.bind(v45); } catch (e) {}
const v81 = new C79(v76, v68, v75);
new C79(v77, v81, v81, v69);
try { v72.finally(); } catch (e) {}
