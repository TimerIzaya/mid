try {
    const v2 = new Int32Array(7);
    if (7) {
        Object.defineProperty(v2, "buffer", { writable: true, configurable: true, enumerable: true, value: Int32Array });
    } else {
        const t5 = 7;
        t5[3] = 7;
    }
} catch(e3) {
}
try {
    new BigInt64Array(255);
} catch(e7) {
}
try {
    new BigInt64Array(1315);
} catch(e11) {
}
let v12 = 1919218961;
class C18 extends BigInt64Array {
    p(a20, a21, a22, a23) {
        try {
            v12 &&= 255;
        } catch(e24) {
        }
        return Int32Array;
    }
    1 = 1.0;
    static #toString(a26, a27, a28, a29) {
        delete this[1894767853];
        for (let v31 = 0; v31 < 32; v31++) {
            this["p" + v31] = v31;
        }
        return -3.0;
    }
}
const v34 = new C18();
const v35 = new C18();
const v36 = new C18();
function f37() {
}
f37();
const v39 = f37();
function f41(a42, a43, a44, a45) {
    const o46 = {
        "d": 1.0,
    };
    return o46;
}
f41(v36, v35, v36, v36);
f41(v35, v36, v34, v34);
f41(v36, v36, v36, v36);
function F52(a54, a55, a56) {
    if (!new.target) { throw 'must be called with new'; }
    const v57 = this.constructor;
    try { new v57(); } catch (e) {}
    new Int16Array(4096);
    new Uint16Array();
    new Uint32Array();
}
new F52();
new F52(v39, -4096);
