const t0 = [-936145422,536870912,127,257,-36772,-15984,2];
t0.length = 6;
function f3(a4, a5) {
    return a5;
}
new Promise(f3);
class C10 {
    b = 1;
    constructor(a12, a13) {
        let v11 = this;
        a13 = 1;
        function F18(a20, a21, a22, a23) {
            if (!new.target) { throw 'must be called with new'; }
            const v24 = this.constructor;
            let v25;
            try { v25 = new v24(a20, a23); } catch (e) {}
            typeof v25 === "symbol";
        }
        const v29 = new F18(65537, 1073741824, 0.19443453377416953, F18);
        new F18(Date, 0.19443453377416953, 1073741824, v29);
        function f33(a34, a35, a36, a37) {
            return a13;
        }
        Symbol.for(Symbol.toPrimitive.description);
        const v43 = -(-14);
        +v11;
        ++v11;
        Math.sinh(1831999511);
        +v11;
        Math.cos(-14);
        ~v43;
    }
}
const v50 = new C10(1, C10);
new C10(1831999511, 1);
const v52 = new C10(1831999511, 1);
function F53(a55, a56) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.c = C10;
        function f57() {
            return this;
        }
        const v60 = new Array(4096);
        v60.with(4096);
    } catch(e62) {
    }
}
const v65 = 1940694780n ^ 1940694780n;
function F66(a68, a69) {
    if (!new.target) { throw 'must be called with new'; }
    const v70 = this.constructor;
    try { new v70(); } catch (e) {}
    -a68;
}
new F66(Float32Array, v65);
new F53(v50, v50);
new F53(v52, v50);
new F53(v52, v52);
function f80() {
    const o81 = {
    };
    const v82 = o81.d;
    v82();
    return v82;
}
%PrepareFunctionForOptimization(f80);
f80();
%OptimizeFunctionOnNextCall(f80);
f80();
