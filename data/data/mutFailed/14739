const v0 = /[m(?!a)?a\1ECUf4gabc]/gi;
const v1 = /[x][\cz]/gudims;
let v2 = /C(ab|cde)l[x]foo(?<!bar)baz*/udy;
function f3(a4) {
    const o5 = {
        [a4]: v2,
        "e": v2,
        ...v2,
        "c": a4,
        "g": a4,
        [v2]: a4,
        "h": a4,
        __proto__: v0,
        ...v2,
        ...v2,
        ...v2,
        "b": v1,
    };
    return o5;
}
const v6 = f3(v1);
const v7 = f3(v1);
f3(f3);
class C9 extends f3 {
    c = v1;
    static #m(a11, a12) {
        const v14 = [v2];
        Reflect.apply(v1.exec, v0, v14);
        v2--;
        const v21 = v2 | 7.114808917837519e+307;
        Math.cos(a11);
        v2 && v21;
        !v2;
        return 7.114808917837519e+307;
    }
}
new C9(v6, C9);
new C9();
new C9();
new BigInt64Array(2149);
new Uint16Array(3412);
new BigUint64Array(129);
function F46() {
    if (!new.target) { throw 'must be called with new'; }
    function f49() {
        return -9007199254740992n;
    }
    class C50 {
    }
    new C50();
    this.c = 1073741823;
    const o53 = {
    };
    class C54 {
    }
    const v56 = new Set();
    function F57(a59, a60) {
        if (!new.target) { throw 'must be called with new'; }
        try {
            this.d = a59;
        } catch(e61) {
        }
        const v62 = v56[this];
        try {
            new F57(a60, v56, v7, v62);
        } catch(e64) {
        }
    }
}
new F46();
new F46();
new F46();
new Float32Array(561146324);
new Uint32Array(2);
function F77(a79, a80, a81, a82) {
    if (!new.target) { throw 'must be called with new'; }
}
const v83 = new F77(F77, F77, F77, F77);
for (let v84 = 0; v84 < 25; v84++) {
    v83["p" + v84] = v84;
}
class C87 {
    constructor(a89, a90) {
        for (let i = 0; i < 10; i++) {
            this[this];
        }
    }
}
new C87();
function F93(a95, a96) {
    if (!new.target) { throw 'must be called with new'; }
    const t91 = Array(11);
    t91[212] -= 3774;
    this.constructor;
    a95++;
}
const v103 = new F93();
const t97 = v103.constructor;
new t97();
