let v2 = -1024n;
let v4 = 1 > -9007199254740990n;
const v6 = new BigInt64Array(1);
let v7 = v6?.constructor;
v2 = -9007199254740990n;
v7 = BigInt64Array;
try { v6.some(BigInt64Array, BigInt64Array); } catch (e) {}
v4 *= v4;
try {
    v6.at(1);
} catch(e10) {
}
let v11;
try { v11 = new v2(v2, -9007199254740990n, v6); } catch (e) {}
const v14 = Symbol.iterator;
const o23 = {
    [v14]() {
        let v16 = 10;
        const o22 = {
            next() {
                v16--;
                const v20 = v16 == 0;
                const o21 = {
                    "done": v20,
                    "value": v16,
                };
                return o21;
            },
        };
        return o22;
    },
};
new Uint32Array(v11);
new BigInt64Array(9);
/(?:ab)xyz{0,1}/gvdmy;
/[\11]*/ims;
const v31 = /[xyz]/vmy;
function f32(a33) {
    a33 & 1;
    class C36 {
        set g(a38) {
            -11 || a38;
        }
    }
    return a33;
}
Object.defineProperty(v31, "valueOf", { configurable: true, value: f32 });
const v42 = v31 - 4.0;
const v43 = Math.tan(4.0);
v43 + v43;
o23.d -= v42;
Object.defineProperty(v6, 1073741825, { writable: true, configurable: true, get: f32 });
new Int8Array(893);
new Uint8ClampedArray(4);
new Int32Array(16);
new Uint16Array(20);
new BigUint64Array(10);
new Int32Array(1000);
const t3 = 20;
new t3(4);
class C12 extends Uint16Array {
    get e() {
        try {
            this(1);
        } catch(e16) {
        }
        return 20;
    }
    1;
    static #c;
    static #h;
    16 = 20;
    #f;
}
new C12();
const t20 = 20;
new t20();
new C12();
function F20(a22, a23, a24) {
    if (!new.target) { throw 'must be called with new'; }
}
Reflect.construct(F20, [10,Reflect,Reflect], Map);
