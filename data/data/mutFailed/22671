class C2 {
}
let v4 = -(-1e-15);
const v5 = v4--;
const v6 = new Uint16Array(4);
async function f8(a9, a10) {
    return f8;
}
f8.constructor;
function F12() {
    if (!new.target) { throw 'must be called with new'; }
    const v15 = [F12,F12];
    [v15,1141300185,F12];
    let v17 = [this];
    Math.log2(v15);
    const v21 = v17++;
    v21 ^ v21;
    Math.asinh(536870887);
    try {
        class C25 extends this.constructor {
            e = F12;
        }
        C25.caller;
        new C25();
    } catch(e28) {
    }
}
const v30 = new Int32Array(8);
const v33 = new Int32Array(1344);
const v34 = v6.constructor;
try { new v34(); } catch (e) {}
const v39 = new Float64Array([-4294967296]);
new Uint32Array(v39);
const v42 = [4,1344,v33];
const v43 = [v30,v42,v33,1344];
[v43,v43,Int32Array,v42,v42];
new Date(16 | 16);
const v49 = new v5();
const t38 = v49.constructor;
let v51 = new t38();
const v52 = /[\11]/gm;
function f53() {
    return v51 >>>= f53 != v52;
}
%PrepareFunctionForOptimization(f53);
const v64 = [-2,-13,-56984,-56984];
const o69 = {
    ...v43,
    n(a66, a67) {
        class C68 {
        }
    },
    __proto__: v64,
};
const o76 = {
};
function F78(a80, a81) {
    if (!new.target) { throw 'must be called with new'; }
    const v82 = this?.constructor;
    try { new v82(this, a81); } catch (e) {}
    this.c = a80;
}
new F78(-4294967296, 28602970);
o76[Uint32Array] -= -2147483649;
256 << -65535;
+20572;
