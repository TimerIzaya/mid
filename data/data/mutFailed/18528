const v0 = [65536,536870889];
const v1 = [9007199254740991,1073741823,1045234095,-606917325,4096];
const v2 = [468869438,60742,-3905,-65535,129,1929503807,4,-109224323];
class C3 {
    constructor(a5, a6) {
        a6 >>= v2;
        try { a5(a6, v1); } catch (e) {}
        try {
            this.h = v2;
        } catch(e8) {
        }
    }
    p(a10, a11) {
        try {
            v1.c = a11;
        } catch(e12) {
        }
        return a11;
    }
}
const v14 = ([-1.5424212036356715e+308]).shift();
function f15(a16, a17, a18, a19) {
    return 45725n;
}
const v21 = new C3(v0, v0);
new C3(v1, v2);
new C3(C3, v2);
function f26() {
    return f26;
}
class C27 extends v14 {
}
new Int8Array(28);
new Int8Array(13);
for (let v32 = 0; v32 < 5; v32++) {
    function f33() {
        let v35 = ("Vre").codePointAt(v32);
        const v36 = v35--;
        class C37 {
        }
        return v35 ^ v36;
    }
    f33();
    %OptimizeFunctionOnNextCall(f33);
}
new Float64Array(2);
function F43(a45, a46, a47) {
    if (!new.target) { throw 'must be called with new'; }
    const v48 = this.constructor;
    try { new v48(v21, v48); } catch (e) {}
    a45 % a45;
}
const v52 = new Uint8Array();
for (let v53 = 0; v53 < 5; v53++) {
    function f54() {
        v52.__proto__;
        return v53;
    }
    f54();
    %OptimizeFunctionOnNextCall(v14);
}
