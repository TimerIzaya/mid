class C3 {
    static #b = -1000000000.0;
    static toString(a5, a6) {
        c = this;
        return Float64Array;
    }
    static #h = 13;
    static set a(a9) {
        let v10;
        try { v10 = a9(this, a9, a9); } catch (e) {}
        v10?.[3];
        super[this];
    }
    static get f() {
        super[1073741825] = 1073741825;
        return this != this ? this : this;
    }
    2147483649 = 13;
}
let v16;
try { v16 = C3.bind(-1000000000.0); } catch (e) {}
new C3();
const v18 = new C3();
for (const v19 of v16) {
    const v20 = [v16,v19];
    const v21 = [13,v16,-1000000000.0,v20,v20];
    [v21,v16,v19,-1000000000.0,v21];
}
const v23 = new C3();
const v25 = 9007199254740992 >> 9007199254740992;
class C28 {
    static [v23] = -1000000000.0;
    static get a() {
        new C3();
        try {
            C3.valueOf = C28;
        } catch(e32) {
        }
        v25 <= v25 ? v25 : v25;
        return v23;
    }
    [v23] = 13;
    [9007199254740992] = 13;
    static 65536 = -1000000000.0;
    e = C3;
    257;
    static [-14185] = v18;
}
new C28();
new C28();
const v39 = new C28();
v39[257] = v39;
let v40 = 9;
v40 ^ v40;
v40++;
function f43() {
    for (let v44 = 0; v44 < 5; v44++) {
        function F45(a47, a48) {
            if (!new.target) { throw 'must be called with new'; }
            const v49 = this?.constructor;
            try { new v49(a47, a47); } catch (e) {}
        }
        const v51 = new F45();
        v51.length;
        try { v51.constructor(v40); } catch (e) {}
    }
    return f43;
}
%PrepareFunctionForOptimization(f43);
f43();
%OptimizeFunctionOnNextCall(f43);
f43();
