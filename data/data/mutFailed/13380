const v0 = [];
class C1 {
    get c() {
        try {
            this.fuck(v0, this);
        } catch(e4) {
        }
        return v0;
    }
    static e;
    h = v0;
    static #b;
}
const v5 = new C1();
const v6 = new C1();
Object.defineProperty(v5, "b", { writable: true, configurable: true, value: v5 });
const v8 = v0["includes"](v6, v5);
function F9(a11, a12, a13, a14) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.b = v5;
    } catch(e15) {
    }
    try {
        this.d = a12;
    } catch(e16) {
    }
    try {
        this.c = v5;
    } catch(e17) {
    }
}
const v18 = new F9("includes", v0, v6, v0);
const v19 = new F9("includes", v6, v5, "includes");
const v20 = new F9(v6, v0, v19, F9);
v6.h = v6;
new C1();
function f22(a23, a24, a25, a26) {
    a23[2] = a24;
    v8[v20] %= v8;
    try {
        let o29 = {
        };
        function f30(a31) {
            o29 = a31;
            return a31;
        }
        Object.defineProperty(o29, "g", { set: f30 });
        o29.e = -1e-15;
    } catch(e32) {
    }
    -10 instanceof WeakMap;
    new f22();
    new a25();
    return v6;
}
const v39 = f22(v19, v8, v20, v18);
0 - 0;
new Int8Array(0);
257 | 257;
let v47 = new Uint8Array(257);
2625 >>> 2625;
new Int32Array(2625);
Float64Array.__proto__ = Float64Array;
3 ** -7;
const o56 = {
};
const v58 = new Uint8Array(3);
const v60 = new Uint8ClampedArray(v58);
--v47;
v8?.[3261];
v39.c;
f22(v8, v18, v18, v18);
%PrepareFunctionForOptimization(f22);
f22(v8, v18, v18, v18);
f22(v8, v18, v18, v18);
%OptimizeMaglevOnNextCall(f22);
f22(v8, v18, v18, v18);
v60[1];
const v70 = new Uint32Array();
for (const v71 in v70) {
}
