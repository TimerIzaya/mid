const v0 = [2.0];
[1000000000.0,1.7976931348623157e+308,-7.577908590707838,NaN,-4.0,-1.2965222782345005e+307,1.3107994153453953e+308,1000000000000.0];
[2.220446049250313e-16];
let v3 = 3977;
function f5() {
    function F6(a8) {
        if (!new.target) { throw 'must be called with new'; }
        const v9 = this.constructor;
        v9.prototype;
        try { new v9(); } catch (e) {}
    }
    const v12 = new F6(f5);
    new F6(v12);
    return f5;
}
const v14 = f5();
const v15 = new Uint32Array(v3);
new Float32Array(7);
new Float32Array(201);
class C22 extends Float32Array {
    1;
    set d(a24) {
        const v27 = --v3;
        -this;
        Math.random();
        +v27;
        super.byteOffset = this;
    }
    127 = v3;
    [v15] = v0;
    d;
    a;
}
new C22();
new C22();
new C22();
new C22();
gc();
new Uint8Array(v0);
const v43 = new Uint8Array();
const v46 = new Uint32Array();
function f47(a48, a49, a50, a51) {
    a48 - a48;
    a50--;
    a51 >>> a51;
    const v55 = a49--;
    v55 + v55;
    a51 + a50;
    const o69 = {
        "maxByteLength": 2,
        "b": a48,
        m(a59) {
            return v14;
        },
        get e() {
            return v15;
        },
        "c": a51,
        ...v43,
        n(a62, a63) {
            v46[a48] = v46;
            function F64() {
                if (!new.target) { throw 'must be called with new'; }
                try {
                    this.a = 3872;
                } catch(e67) {
                }
            }
            new F64();
            return a63;
        },
    };
    const v70 = [4096,1000,17593,14,569949084,536870888,3,4];
    const v72 = new Uint32Array(2, 2, 2);
    v70[1855803377] = v72.buffer;
    try { o69.n(o69, -2); } catch (e) {}
    return a50;
}
f47(2, 2, 1, 2);
for (let v76 = 0; v76 < 500; v76++) {
    f47(Uint8Array, 2, v76, 2);
}
