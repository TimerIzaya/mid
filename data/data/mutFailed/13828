let v2 = -12;
new Date(v2 % v2);
class C7 {
    #b = v2;
    g = 1.1408591040999836e+308;
    static {
        Object.defineProperty(this, "e", { configurable: true, value: this });
        let v9;
        try { v9 = new this(); } catch (e) {}
        v9.e = v9;
        this.e = this;
        function f11() {
            return Date;
        }
        function f12(a13) {
            const v15 = new Map();
            try { a13.valueOf(v9, v15, v9); } catch (e) {}
        }
        Object.defineProperty(Math, "toString", { configurable: true, get: f11, set: f12 });
        try { Math.tan(Math); } catch (e) {}
        let v19 = 44149;
        -v19;
        v19--;
        const v22 = v2++;
        const v23 = v22 & v22;
        let v24 = -v22;
        v24++;
        let v26 = ~v2;
        v26--;
        Math.log10(v19);
        const v29 = v19 + v2;
        v29 + v23;
        v29 >> v29;
        const v32 = Math.fround(v22);
        v32 >> v32;
    }
}
try { new C7(); } catch (e) {}
function F40() {
    if (!new.target) { throw 'must be called with new'; }
    function f43(a44) {
        return F40;
    }
    this.onmessage = f43;
    const o47 = {
        "type": "function",
    };
    new Worker(F40, o47);
}
new F40();
function f55(a56, a57) {
    const o58 = {
        "d": a57,
        "c": -5,
    };
    return o58;
}
class C61 {
}
function F63(a65, a66, a67) {
    if (!new.target) { throw 'must be called with new'; }
    const v68 = this.constructor;
    try { new v68(this, a67, -14); } catch (e) {}
    a67.valueOf(a65, a67);
}
const v74 = [];
const v75 = [v74,v74,v74,v74];
const v76 = [v75,v75,v75];
function f77() {
    return v76;
}
f77();
("toString").match();
