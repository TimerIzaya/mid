function f0() {
}
const v5 = new Uint16Array(256);
const v7 = new Float64Array(128);
function F8(a10, a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
    a11 >> a11;
    a13 | a13;
    v7.b = a11;
    for (const v16 of v5) {
        Uint32Array?.h;
    }
}
const v18 = new F8(128, 256, 128);
const v19 = /(x)(x)(x)(x)(x)(x)(x)(x)(x)(x)\10/u;
const v20 = [Infinity];
const v22 = ([2.2250738585072014e-308,1.949684848262672,4.0]).push(v19);
const v23 = [342.12300421344116,0.3998304334347528,-1.5569468467414895e+308,929110.7069466491,0.8403359879371063,928.8415619105033,5.0];
const v24 = v23.toStringTag;
let v25;
try { v25 = v20.every(v24, v18); } catch (e) {}
new F8(v24, v25, v25, v22);
const v27 = new Uint32Array(128);
const v28 = (256).unshift(v27);
class C29 {
    static [v7] = v28;
}
const t27 = "symbol";
delete t27[1];
function f33(a34, a35, a36, a37) {
    try { a34(v23); } catch (e) {}
    a36 >> a36;
    return v23;
}
new Int8Array(255);
const t35 = [1073741823,64,-192774235];
t35.length = 127;
new Uint8ClampedArray(v22);
new Uint32Array(3712);
const v52 = new Int8Array(256);
v52.indexOf();
Int32Array.bind().name.normalize();
const v59 = new Float32Array(10, 10, 10);
const v61 = new Float64Array();
v61[10] = v59;
const t45 = "byteOffset";
t45[4] = Float64Array;
