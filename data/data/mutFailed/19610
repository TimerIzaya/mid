const v0 = [257,-2147483649,0];
[806708344,-128,9,7,1514143929,1967254376];
[-868692135,-41843,12,-525202295];
const v3 = [536870887,-1314597871,1247685076,1007727974,268435456,2147483649];
[-644778719,37573,-1332496471,-14231,-48693,1073741824,16,65535,4096,-1];
const v5 = [-2,4];
class C6 {
    static {
        v0 && v0;
        const v9 = this[0];
        try { v9(v3); } catch (e) {}
        const o13 = {
            "maxByteLength": 3516,
        };
        const v15 = new SharedArrayBuffer(3516, o13);
        new BigUint64Array(v15);
    }
}
const v18 = new C6();
const v19 = new C6();
const v20 = new C6();
[C6,v5,v20,v19,v3];
[v20,v18,v0,v5];
[v3];
const v26 = new Uint8ClampedArray();
const v29 = new Uint8ClampedArray(798, ...v26, eval());
new Date();
function f32(a33) {
    function f34(a35, a36, a37) {
    }
    const v39 = new Int16Array();
    function f41(a42, a43) {
        delete arguments[2];
        return a43;
    }
    f41(v39, v39, -1.7976931348623157e+308);
}
const v47 = f32(f32);
f32();
new Set();
function F51(a53, a54, a55) {
    if (!new.target) { throw 'must be called with new'; }
}
new F51(v47);
v29.bind();
const v58 = [];
function f59() {
    const o63 = {
        toString() {
            super[this];
            return this;
        },
        ...v58,
        n() {
            return this;
        },
    };
}
%PrepareFunctionForOptimization(f59);
for (let v64 = 0; v64 < 25; v64++) {
    const v65 = [601759695];
    const v66 = [1073741824,1073741823,1376142744,1073741825];
    function f67(a68, a69, a70, a71) {
        try { v66["find"](..."find", a71, ...v65); } catch (e) {}
        const v74 = [Set];
        [v74,v74,v64];
        v65 || f32;
    }
    for (let v77 = 0; v77 < 5; v77++) {
        f67();
    }
}
