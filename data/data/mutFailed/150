class C3 {
    constructor(a5) {
        a5 | a5;
        a5 + a5;
        try { this.isArray(1011250639, this, -2, this); } catch (e) {}
        try {
            super.p();
        } catch(e10) {
            const v11 = e10.message;
            v11[37] = v11;
        }
    }
    set g(a13) {
        const v14 = this?.constructor;
        try { new v14(C3); } catch (e) {}
        a13.length = a13;
        Object.defineProperty(this, 1000, { writable: true, configurable: true, value: a13 });
        let v16;
        try { v16 = a13(1011250639, this, 1011250639, this); } catch (e) {}
        class C17 {
            static [a13];
            static 10 = v16;
        }
        C17[10] = C17;
        new C17();
        const v19 = new C17();
        const v20 = v19?.constructor;
        try { new v20(); } catch (e) {}
        const v22 = new C17();
        const v23 = v22?.constructor;
        try { new v23(); } catch (e) {}
    }
}
try { new C3(C3); } catch (e) {}
C3.a = C3;
new C3(1011250639);
const v27 = new C3(1011250639);
const v28 = new C3(1011250639);
v28.g = v28;
function F29(a31, a32) {
    if (!new.target) { throw 'must be called with new'; }
    const v33 = this?.constructor;
    try { new v33(a32, this); } catch (e) {}
    const v35 = a31 / a31;
    v35 ^ v35;
    try {
        this.d = a31;
    } catch(e37) {
    }
    try {
        this.g = v27;
    } catch(e38) {
    }
    try {
        this.a = a31;
    } catch(e39) {
    }
}
F29.d = F29;
new F29(-145528610, 1011250639);
new F29(-145528610, -145528610);
new F29(-2, -145528610);
Float32Array.prototype = Float32Array;
const v45 = new Float32Array(0);
try { v45.entries(); } catch (e) {}
try { v45.set(C3); } catch (e) {}
512 & 512;
new Int32Array(512);
const v53 = 2529 !== 2529;
v53 && v53;
const v56 = new Uint32Array(2529);
let v57 = v56[355];
v57--;
const v60 = [1000,1000,1000,1000,1000];
try { v60.values(); } catch (e) {}
for (let i = 0; i < 5; i++) {
    Object.defineProperty(v60, 130, { value: 1000 });
}
function F3(a5, a6) {
    if (!new.target) { throw 'must be called with new'; }
    function f7() {
        const v9 = new BigInt64Array();
        const o10 = {
            1073741824: v9,
            9: v9,
        };
        return BigInt64Array;
    }
    a6[Symbol.toPrimitive] = f7;
    a5 >> a5;
    try {
        this.h = 628n;
    } catch(e14) {
    }
    try {
        this.f = 3n;
    } catch(e15) {
    }
    try {
        this.d = a6;
    } catch(e16) {
    }
}
try { new F3(3n, F3); } catch (e) {}
const v18 = new F3(3n, 35294n);
new F3(3n, v18);
let v20 = new F3(35294n, v18);
let v21 = 6;
v21--;
new Int16Array(v21);
new Uint8ClampedArray(16);
new Int32Array(2614);
[1000000000.0,-1000.0,-690.3798026183179,8.153290522672417e+306,2.0,-1000000.0,-1000000000.0];
const v32 = [172808.41555842035,6961.648758031544,-1000000000.0,-3.0,-3.473146185040173e+307,-421.3362201856155,-879.0794661120945,-5.0,-2.4710773994464814e+307,1000000000000.0];
[2.0,67588.71976092551,987444.2991633068,0.4770197645753065,1000000.0,-212679.8858953634,-1e-15,-3.0];
const v35 = 10 >> 10;
new BigUint64Array(10);
try { Uint32Array.from(1024); } catch (e) {}
const v41 = new Uint32Array(1024);
v41[916] = v41;
Uint32Array.d = v35;
Uint32Array.d = Uint32Array;
const v44 = new Uint32Array(10);
[-1000.0,5.0,720584.9706165395,-2.220446049250313e-16];
[1.0,-7.897761779739891];
[1000000.0,5.0,1000.0,0.5082630760435969];
try {
    const v48 = new Uint32Array(v44);
    const v49 = v48?.findLastIndex;
    try { new v49(v32); } catch (e) {}
} catch(e51) {
}
const v52 = new Uint32Array(10);
function f53() {
    try {
        v20 >>>= v18;
    } catch(e54) {
    }
    return v18;
}
v52[Symbol.toPrimitive] = f53;
v52[6] = v52;
try { ("minor").indexOf(v18); } catch (e) {}
const o61 = {
    "execution": "sync",
    "type": "minor",
};
gc(o61);
