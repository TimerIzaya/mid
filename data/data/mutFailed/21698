function f0() {
    const o10 = {
        "g": Infinity,
        m(a5) {
            let v6;
            try { v6 = ("boolean").substring(a5, a5); } catch (e) {}
            const v7 = `isArray${"toTimeString"}boolean${Infinity}symbol${a5}m`;
            if (v7 > v7) {
                super[v6];
            } else {
                v7["toTimeString"] = "toTimeString";
            }
            return v7;
        },
        "f": "boolean",
        "a": Infinity,
    };
    return o10;
}
const v11 = f0();
const v12 = f0();
const v13 = f0();
function F14(a16) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.d = a16;
    } catch(e17) {
    }
    try {
        this.b = a16;
    } catch(e18) {
    }
}
new F14(v12);
new F14(v12);
new F14(v13);
WeakMap >> v11;
const v28 = v11 * WeakMap;
Math.imul(v28, f0);
-72561382 % v11;
new WeakMap();
new Uint16Array(9);
new BigInt64Array(35);
const v40 = new BigInt64Array(255);
class C41 {
    constructor(a43, a44) {
        let v45 = 10;
        for (let i = 0; i < 5; i++) {
            const v46 = v45--;
            function f47(a48, a49, a50, a51) {
                for (const v52 of v40) {
                    new WeakMap();
                }
                this[f0] /= v28;
                const v56 = new Int16Array();
                async function f58(a59, a60, a61) {
                    for (const v62 of a43) {
                        -740089575 ^ v45;
                    }
                    await v56[1];
                }
                f58().finally(Uint8Array);
                return v46;
            }
            for (let v69 = 0; v69 < 5; v69++) {
                f47();
            }
            %OptimizeFunctionOnNextCall(f47);
        }
    }
}
new C41(C41, C41);
