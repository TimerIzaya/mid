const v2 = new Int8Array(127);
Float64Array.BYTES_PER_ELEMENT = 127;
const v5 = new Float64Array(3);
Uint32Array.name = Uint32Array;
const v8 = new Uint32Array(2);
class C9 {
    static o(a11, a12) {
        try {
            this.e = 3;
        } catch(e13) {
        }
        return Float64Array;
    }
    6;
    static h;
    constructor(a15, a16, a17) {
        this[6] = this;
        a15 & a15;
        a16 < a16;
        a17 >>> a17;
        const v21 = delete v5[v2];
        v21 || v21;
        Float64Array.length;
        const v25 = v2 || Int8Array;
        v25[94] = v25;
    }
}
let v26;
try { v26 = C9.o(2, v5); } catch (e) {}
const v27 = new C9(2, 3, 3);
const v28 = new C9(2, 2, Float64Array);
const v29 = new C9(2, 127, Float64Array);
v29[6];
function f31(a32, a33) {
    a33[2] = a33;
    const o45 = {
        "e": Uint32Array,
        "d": a32,
        "g": a32,
        [a33]: a33,
        [C9]: v2,
        "b": a32,
        set h(a35) {
            function f37(a38, a39, a40) {
                const o41 = {
                    "b": a39,
                };
                return o41;
            }
            f37(v28, a32, a33);
            f37(v27, a32, v29);
            f37(this, 2, a33, 2, f31);
        },
    };
    return o45;
}
f31(2, v5);
f31(3, v8).d;
f31(3, v27);
function F50() {
    if (!new.target) { throw 'must be called with new'; }
    const v52 = this?.constructor;
    try { new v52(); } catch (e) {}
}
const v54 = new F50();
[-207.12380510118123,-982114.0356244294,0.9612192807513333,-3.0,-1000.0,1.0];
for (let v56 = 0; v56 < 5; v56++) {
    function f57() {
        try {
            v56.forEach();
        } catch(e59) {
            e59.a = e59;
            e59.a = v54;
            e59.a = v26;
        }
        const v61 = Symbol.toPrimitive;
        Symbol.for(v61.description);
        v61.description;
        Symbol.for();
        return v61;
    }
    f57.caller = f57;
    v27();
    %OptimizeFunctionOnNextCall(f57);
}
