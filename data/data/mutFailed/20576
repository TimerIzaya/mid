const v1 = [-11,-9223372036854775807,-817733745,9007199254740991,16,12,-16238,536870912,-4294967297,65536];
const v2 = /[^7Y[a-zA-Z0-9]?]/vdmy;
for (let v3 = 0; v3 < 5; v3++) {
    function f4() {
        const v6 = isFinite(v1);
        try { v6.reduceRight(v2); } catch (e) {}
        return v1;
    }
    f4();
    %OptimizeFunctionOnNextCall(f4);
}
function F14(a16, a17) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.d = -35040;
    } catch(e18) {
        const v21 = new Uint8ClampedArray(Uint8ClampedArray);
        new Int8Array(v21);
    }
}
new F14(-1242750079, -1593851866);
new F14(-1242750079, 127);
const v26 = new F14(-1242750079, -1893547963);
const v38 = new Int16Array(-1000000000.0);
new Uint8Array(255);
const v44 = new Int16Array(8);
async function f46(a47, a48, a49) {
    delete v44[-1000000000.0];
    let [v51,v52,...v53] = v38;
    v38[5];
    await v52;
    return parseFloat;
}
const v57 = new Set();
v57.add;
function F59(a61, a62) {
    if (!new.target) { throw 'must be called with new'; }
    a61[4] = a61;
    this.valueOf().constructor;
    try { new this(); } catch (e) {}
    a61[4];
}
f46(8, 8, 948737.12760097);
const v70 = +v26;
const v72 = 135.68951961804942 / (-36313 + 135.68951961804942);
const v74 = ([16,-1337814116,1282563165,-268435456,-256,58611,-4294967296,-10,-9223372036854775807,9]).keys();
function f75(a76, a77) {
    const o78 = {
        "g": v74,
    };
    return o78;
}
%PrepareFunctionForOptimization(f75);
v70 || v72;
