class C3 {
    static c;
    constructor(a5) {
        this[1];
        a5.c = a5;
        let v7 = this % a5;
        v7 + v7;
        let v9 = a5 >>> v7;
        16 % 10000;
        [v9,v7] = "getFloat32";
        try {
            v7.length = 1;
        } catch(e12) {
        }
    }
    1;
    static ["getFloat32"] = 16;
}
C3.b = C3;
const v13 = new C3(C3);
const v14 = new C3(16);
v14[1];
const v16 = new C3(v13);
const v17 = [10000,v16,16,v16];
const v18 = [v13,v14,"getFloat32",v17];
[v17];
class C20 {
    static 1 = v17;
    toString(a22, a23, a24, a25) {
        a24 = a25;
        let v26;
        try { v26 = a23.clear(16, a23, v17); } catch (e) {}
        super.a = a25;
        Reflect.construct(v26, [v26,v26,v14,v18], C3);
        return Reflect;
    }
    static c = v13;
    static [-1];
    [v18];
    static #h = "getFloat32";
}
try { new C20(); } catch (e) {}
new C20();
new C20();
new C20();
function F34() {
    if (!new.target) { throw 'must be called with new'; }
    this.d = -15;
}
F34.prototype;
F34.fuck = F34;
class C38 extends F34 {
}
try { new C38(); } catch (e) {}
class C40 extends C38 {
    set d(a42) {
        a42 + a42;
        for (const v44 in C38) {
        }
    }
}
C40.name = C40;
new C40();
const v46 = new C40();
const v47 = v46?.valueOf;
try { new v47(); } catch (e) {}
