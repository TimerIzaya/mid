new Date();
new Float64Array(257);
const v13 = new Int32Array(1);
(2136873598).constructor;
function F18(a20, a21) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        const v23 = Symbol.iterator;
        const o25 = {
            [v23]() {
            },
        };
    } catch(e26) {
    }
    try {
        new F18();
    } catch(e28) {
    }
}
new F18();
new Int32Array(6);
-445432.6168126359 > v13 ? -445432.6168126359 : v13;
Date.h = [];
function f34(a35, a36, a37, a38) {
    const v39 = a36 >>> a36;
    let v40 = v39 >>> v39;
    v40--;
    return v40;
}
f34();
%OptimizeFunctionOnNextCall(f34);
Date(1);
const o46 = {
    "maxByteLength": 512,
};
const v48 = new ArrayBuffer(512, o46);
new Float64Array(v48);
class C52 extends Float64Array {
    constructor(a54) {
        Math.round(Math);
        async function f63(a64, a65, a66) {
            return 268435440;
        }
        Math.pow(268435456, 65536);
        const v70 = new BigInt64Array(4046);
        let o71 = {
        };
        [,...o71] = v70;
        268435456 ^ (-1e-15 && 65536);
    }
}
const v77 = Date(63929);
function F80(a82, a83) {
    if (!new.target) { throw 'must be called with new'; }
    const v85 = this.valueOf().constructor;
    try { new v85(v85, v85, v85, a83); } catch (e) {}
    F80 instanceof BigInt64Array;
}
new F80();
const v89 = new C52();
function f90(a91, a92, a93) {
    return a92;
}
const v96 = [v89];
const o102 = {
    "arguments": v96,
    toString(a98, a99) {
        return (2136873598 && v77) <= v96;
    },
    "arguments": v96,
    "type": "function",
};
new Worker(f90, o102);
(10).toFixed(10, 10);
function F106() {
    if (!new.target) { throw 'must be called with new'; }
}
const v109 = -9007199254740991 >> -9007199254740991;
v109 - v109;
