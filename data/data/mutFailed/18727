new Set();
0 < 4;
function f7(a8, a9, a10, a11) {
    return Reflect.construct(Uint8ClampedArray, []);
}
%OptimizeFunctionOnNextCall(f7);
new Float64Array(2279);
if (Float64Array == 2279) {
    ("defineProperty")[4];
} else {
    const t10 = "defineProperty";
    t10[7] = "boolean";
    const o24 = {
        "maxByteLength": 8,
    };
    const v26 = new ArrayBuffer(8, o24);
    new DataView(v26);
}
const v31 = new Uint32Array(64);
function F33(a35, a36) {
    if (!new.target) { throw 'must be called with new'; }
    const v37 = this.constructor;
    try { new v37(); } catch (e) {}
    ~a36;
}
new F33();
const v42 = new Uint8Array(127);
let v43 = -1073741824;
v43--;
const v45 = [1073741824,1073741823,1376142744,1073741825];
const v49 = BigUint64Array * 536870887;
function f50(a51, a52, a53, a54) {
    const o55 = {
    };
}
Object.defineProperty(v42, "d", { writable: true, get: f50, set: f7 });
const t36 = "boolean";
t36[3] &= 64;
try {
    v42.d = 64;
} catch(e57) {
}
let v58 = -9223372036854775808n;
v58 %= 45725n;
const v60 = v49 ** v49;
new Float64Array();
function F63(a65, a66, a67, a68) {
    if (!new.target) { throw 'must be called with new'; }
    const v69 = this.constructor;
    try { new v69(a65); } catch (e) {}
    this.c = a65;
}
let v71 = ~v31;
function F72(a74, a75) {
    if (!new.target) { throw 'must be called with new'; }
    const v76 = this.constructor;
    let v77;
    try { v77 = new v76(F72, v76, F72, F72); } catch (e) {}
    const v79 = v77 >>> 38445;
    let v80 = 0;
    while (v80 < 1) {
        v71 = v79;
        Object.defineProperty(v45, v60, { writable: true, enumerable: true, set: f50 });
        v80++;
    }
    38445 >> v77;
    let v85 = v79 * v79;
    v85--;
}
const v87 = new Int8Array(v45);
v87.includes(v71);
v87.lastIndexOf(v43);
