const v1 = new Date();
function f2(a3, a4) {
    const v7 = ([Reflect,Reflect])[1];
    v7.set(v7);
    return v1;
}
v1.toString = f2;
function F9(a11, a12) {
    if (!new.target) { throw 'must be called with new'; }
    function f13(a14) {
        a14[2866241325] = F9;
        const v15 = [];
        [v15,v15,v15,v15,v15];
        return f2;
    }
    this.constructor = f13;
    function f17() {
        return f13;
    }
    function f18(a19) {
        try {
        const t0 = 0.44967380041772886;
        t0();
        } catch (e) {}
    }
    Object.defineProperty(a11, "toString", { get: f17, set: f18 });
    try { a11(a12, a12); } catch (e) {}
    try { this.constructor(v1, a11); } catch (e) {}
    try { a11.call(this); } catch (e) {}
    this.f = Date;
    try {
        this.b = a12;
    } catch(e25) {
    }
    try {
        this.f = v1;
    } catch(e26) {
    }
}
const v27 = new F9(F9, F9);
v27.e = v27;
const v28 = new F9(v1, Date);
v28.f;
const v30 = new F9(F9, v28);
let v33 = 26940 + 26940;
const v34 = v33++;
const v36 = [1073741824,1073741824,v27];
v36.g = v34;
try { v36.fill(v36); } catch (e) {}
v36.g = v36;
const v38 = [26940,v36,v30];
[v38,v38,v30];
let v41;
try { v41 = new TypeError(v1); } catch (e) {}
v41.a = v41;
v41.a = v41;
class C42 extends TypeError {
}
try { new C42(); } catch (e) {}
new C42();
