let v1 = "symbol";
let v2 = -53474;
class C3 {
    static get b() {
        v1[this] = v1;
        super.d = this;
        typeof this === "boolean";
        return -256;
    }
    [v2];
    constructor(a9) {
        [] = v1;
        [] = v1;
        const v10 = v1[v2];
        a9 /= a9;
        super.a = v1;
        v10[v1] = this;
        ({"c":v2,"e":v1,"f":v1,...v1} = v10);
    }
}
const v11 = new C3(C3);
new C3(v11);
const v13 = new C3(v1);
function F18() {
    if (!new.target) { throw 'must be called with new'; }
}
let v22;
try { v22 = Uint32Array.apply(F18); } catch (e) {}
function F23(a25, a26, a27, a28) {
    if (!new.target) { throw 'must be called with new'; }
    const v29 = a26.constructor;
    const v31 = new Set();
    const v32 = v31.keys;
    let v33;
    try { v33 = v32(C3, v29, 3228, a25); } catch (e) {}
    function F34(a36, a37) {
        if (!new.target) { throw 'must be called with new'; }
        try {
        } catch(e38) {
        }
        try {
            this.h = v31;
        } catch(e39) {
        }
        try {
            const v40 = v31[this];
            try {
                new F34(v40, -268435456n);
            } catch(e43) {
            }
        } catch(e44) {
        }
        switch (3228) {
            case v33:
                v29[5] = v22;
                break;
        }
    }
    new F34();
    new F34();
    new F34(a26, a27);
}
function F50(a52, a53, a54, a55) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.g = a53;
    } catch(e56) {
    }
    try {
        this.h = C3;
    } catch(e57) {
    }
}
new F50(v2, -256, v11, v11);
const v59 = new F50(F50, 268435440, v11, v11);
new F50(50162, 268435440, v13, v59);
function f61(a62, a63) {
    function f64() {
        return f61;
    }
    Object.defineProperty(a62, "toString", { configurable: true, get: f64 });
    return a63;
}
f61(f61);
f61(f61);
