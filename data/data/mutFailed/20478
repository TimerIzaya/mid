let v3 = 10;
const v4 = v3 & v3;
try {
const t0 = 6;
t0(6, 1, 4294967297, 4, 4);
} catch (e) {}
const t6 = 4294967297;
const v11 = delete t6?.g;
function f12(a13, a14, a15, a16) {
    try { a13(4294967297); } catch (e) {}
    a15 >> a15;
    return 4294967297;
}
for (let v19 = 0; v19 < 500; v19++) {
    f12(6, f12, v19, 6);
}
const v21 = v11 || 6;
const v25 = Math.sign(6);
Math.log10(v21);
const v27 = 4294967297 - 6;
4 === 4;
function f29() {
}
v3--;
const v31 = [1];
Object(10);
async function* f35(a36, a37, a38) {
    await "NEGATIVE_INFINITY";
    try {
        yield* [v11,"undefined"];
    } catch(e44) {
    }
    return 536870887;
}
f35(v25, v27, 6);
try { new Float64Array(Float64Array, 4, 6); } catch (e) {}
const v49 = new Float64Array(128);
new Int8Array(3938);
(4294967297).includes(-65535);
try { Float32Array.bind(4); } catch (e) {}
const v58 = new Float32Array(4);
v58[1] = v58;
v49[Symbol.isConcatSpreadable] = v4;
function f63() {
    return -2147483648;
}
const v65 = [-2,1024];
function F66(a68, a69, a70, a71) {
    if (!new.target) { throw 'must be called with new'; }
    for (let v72 = 0; v72 < 100; v72++) {
        for (let v73 = 0; v73 < 5; v73++) {
            function f74() {
                return v73;
            }
        }
        Array / v65.length;
    }
}
new Uint16Array(16);
async function f78(a79, a80, a81) {
    return a80;
}
function f82(a83, a84, a85, a86) {
    Math.round();
    return Math;
}
%OptimizeFunctionOnNextCall(f82);
function f89() {
    48342 >>> 48342;
    let v93;
    try { v93 = new Int32Array(v58, Int32Array, v49); } catch (e) {}
    const v94 = new Int32Array(48342, Float64Array, v93);
    for (const v95 of v94) {
        v95 - v95;
        const v98 = new Date();
        v98.getHours();
        typeof 522675525n;
    }
    return Int32Array;
}
v31();
