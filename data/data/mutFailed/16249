[];
new Uint32Array();
class C3 {
}
new C3();
function f5() {
    return f5;
}
new BigInt64Array(128);
const v10 = [7.830634752107482,0.006033685793877752,202369.19324926357,5.9519043173705874,5.0];
const v13 = new Int8Array(10);
const v14 = [-536870912,-3592,61205];
const o15 = {
};
o15.a = v10;
o15.f = v13;
o15.g = v14;
new Int16Array(Int16Array);
new Int8Array(9);
const o25 = {
};
class C26 {
    constructor(a28, a29, a30) {
        class C32 extends a29.constructor {
        }
        new C32();
    }
}
function f35(a36, a37, a38, a39) {
    const o46 = {
        set g(a41) {
            for (const v42 of a41) {
                try { v42.keys(this, this); } catch (e) {}
                v42[a41] = a41;
            }
            try {
                super.map();
            } catch(e45) {
            }
        },
        "a": a36,
        [a37]: 268435456n,
    };
    function f47(a48, a49) {
        const o50 = {
            ...a48,
        };
        o50.d;
        return f47;
    }
    f47.d = f47;
    %OptimizeFunctionOnNextCall(f47);
    return o46;
}
const v52 = f35(-128n, 16n, -128n, 268435441n);
const v53 = f35(16n, 16n, 268435456n, 4n);
const v54 = f35(16n, 4n, -128n, 268435441n);
function F55(a57, a58, a59, a60) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.g = 4n;
    } catch(e61) {
    }
    try {
        this.h = a57;
    } catch(e62) {
    }
}
new F55(4n, 268435456n, v52, 4n);
new F55(268435441n, 268435441n, v53, -128n);
function f68(a69, a70) {
    const o72 = {
        get c() {
            let v71 = this;
            v71 += v71;
            return a70;
        },
        "b": -65537n,
        __proto__: a69,
        ...a69,
        "a": a70,
        6: 4294967297n,
        "c": 4294967297n,
    };
    return o72;
}
f68(f68, -65537n);
Reflect.construct(f68(f68, f68).h, [4294967296n]);
new F55(1000n, -128n, v54, 268435456n);
function f80() {
    class C81 {
    }
    for (let v82 = 0; v82 < 5; v82++) {
        "p" == "p";
        new Uint32Array(159);
        const o88 = {
        };
        try { ("p").substring(C81, C81); } catch (e) {}
    }
    for (let i104 = (() => {
            const v92 = new Uint8Array(Uint8Array);
            function f93(a94, a95, a96, a97) {
                const v98 = a96++;
                v98 * v98;
                a96 % a96;
                const o101 = {
                    ...v92,
                };
                o101[2];
                let v103;
                try { v103 = o101.n(a95); } catch (e) {}
                return v103;
            }
            return 0;
        })();
        i104 < 1;
        ) {
        function F109(a111, a112, a113) {
            if (!new.target) { throw 'must be called with new'; }
        }
    }
    return f80;
}
