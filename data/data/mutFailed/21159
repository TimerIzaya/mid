const v0 = [];
let v4 = [-45397,-23698,v0];
[-13,v0,-13];
const v6 = [-13];
function f7(a8, a9) {
    const o27 = {
        get d() {
            for (let i12 = 0; i12 < 5; i12++) {
                a8 >>>= i12;
                v4 /= v6;
                Math.log2(-13);
                Math.tanh(a8);
                +0.9524554957473453;
                const v24 = ++v4;
                0.9524554957473453 % a8;
                -v24;
            }
            return this;
        },
    };
    return o27;
}
const v28 = f7(-23698, -23698);
const v29 = f7(-23698, -45397);
const v30 = f7(v4, -45397);
function f31() {
    const v32 = -13 >= v30;
    delete v0[2];
    const v34 = v32 / v4;
    %VerifyType(v34);
    v34[5] = v4;
    return v30;
}
function F35(a37, a38) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.e = -13;
    } catch(e39) {
    }
    try {
        this.h = a37;
    } catch(e40) {
    }
}
new F35(-45397, v28);
new F35(v4, v29);
new F35(-23698, v28);
class C44 {
}
const v45 = new C44();
function f46(a47, a48) {
    function f49() {
        const v50 = /(?:a*)+q(?<a>.)/guds;
        for (let i53 = 0, i54 = 10;
            (() => {
                const v55 = i53 < i54;
                f49();
                %PrepareFunctionForOptimization(f49);
                f49();
                f49();
                %OptimizeMaglevOnNextCall(f49);
                f49();
                return v55;
            })();
            i54--) {
            v50.test(v50);
        }
        return v50;
    }
    %PrepareFunctionForOptimization(f49);
    f49();
    %OptimizeFunctionOnNextCall(f49);
    f49();
    return f49;
}
Object.defineProperty(v45, "constructor", { value: f46 });
const t76 = v45.constructor;
t76(f46, v45);
