class C3 {
    static m(a5, a6) {
        const t2 = "n";
        t2[208] **= a5;
        let v8 = 65537;
        Math.pow(v8, a6);
        ++v8 * v8;
        !a6;
        return a6;
    }
    c = "MIN_SAFE_INTEGER";
}
const t12 = "MIN_VALUE";
const v13 = new t12();
const v14 = new C3();
const v15 = new C3();
v15.b = v15;
function F16(a18, a19) {
    if (!new.target) { throw 'must be called with new'; }
    try { this.constructor(this, a18); } catch (e) {}
    try { a19.strike(); } catch (e) {}
    try {
        this.a = v14;
    } catch(e22) {
    }
    try {
        this.f = C3;
    } catch(e23) {
    }
    try {
        const v24 = C3[-1];
        let v25;
        try { v25 = v24.m(v24, v24); } catch (e) {}
        let v26;
        try { v26 = ("MIN_VALUE").matchAll(v25); } catch (e) {}
        try { v26.next(); } catch (e) {}
        9223372036854775807n * 9223372036854775807n;
        this.g = v13;
    } catch(e32) {
    }
}
const v35 = -Infinity;
v35 - v35;
v13 % v35;
const v38 = -v13;
~v38;
const v40 = -v38;
const v41 = -14406 ^ v40;
v41 > v41;
v35 / v13;
const v44 = ~v40;
new F16("MIN_SAFE_INTEGER", v44);
const v46 = new F16("MIN_VALUE", "MIN_VALUE");
const v47 = v46?.constructor;
try { new v47(v46, v44); } catch (e) {}
const v49 = new F16("MIN_SAFE_INTEGER", "MIN_VALUE");
v49.BYTES_PER_ELEMENT = Float32Array;
const v52 = new Float32Array(4061);
const v53 = v52.indexOf();
v53 >>> v53;
