new Set();
0 < 4;
function f7(a8, a9, a10, a11) {
    const v14 = [];
    Reflect.construct(Uint8ClampedArray, v14);
    return v14;
}
%OptimizeFunctionOnNextCall(4);
new Float64Array(2279);
const v22 = new Uint32Array(64);
function F24(a26, a27) {
    if (!new.target) { throw 'must be called with new'; }
    const v28 = this.constructor;
    try { new v28(); } catch (e) {}
    ~a27;
}
new F24();
new Uint8Array(127);
let v34 = -1073741824;
v34--;
const v36 = [1073741824,1073741823,1376142744,1073741825];
[11,2080491998];
[9,-9007199254740990];
0 || [977992275,12,-9007199254740992];
Object.defineProperty("6MR", 1, { get: f7, set: f7 });
const v44 = BigUint64Array * 536870887;
function f45(a46, a47, a48, a49) {
    const o50 = {
    };
}
let v51 = -9223372036854775808n;
v51 %= 45725n;
v44 ** "boolean";
new Float64Array();
function F56(a58, a59, a60, a61) {
    if (!new.target) { throw 'must be called with new'; }
    const v62 = this.constructor;
    try { new v62(a58); } catch (e) {}
    this.c = a58;
}
const v64 = ~v22;
function F65(a67, a68) {
    if (!new.target) { throw 'must be called with new'; }
    const v69 = this.constructor;
    let v70;
    try { v70 = new v69(F65, v69, F65, F65); } catch (e) {}
    const v72 = v70 >>> 38445;
    38445 >> v70;
    let v74 = v72 * v72;
    v74--;
}
const v76 = new Int8Array(v36);
v76.includes(v64);
v76.lastIndexOf(v34);
