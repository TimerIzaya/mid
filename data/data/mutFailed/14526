class C2 {
    static {
        const v4 = this.toString();
        try { v4(); } catch (e) {}
    }
}
class C7 {
    63;
    constructor(a9, a10) {
        let v8 = this;
        throw -65535n;
        a10?.[3];
        v8 *= a10;
    }
    o(a13) {
        try {
            this.fuck(a13, a13, 6.941367376283275e+306);
        } catch(e16) {
        }
        return 11n;
    }
    1130;
}
new C7(11n, -9n);
new C7(11n, 11n);
const v19 = new C7(-9n, C7);
function F22(a24, a25, a26, a27) {
    if (!new.target) { throw 'must be called with new'; }
}
const v28 = v19.constructor();
const o29 = {
    "execution": v28,
};
class C33 {
    #n(a35, a36, a37, a38) {
        super[this] = this;
    }
}
const v41 = new BigInt64Array();
v41.copyWithin(-9223372036854775808);
function F44(a46, a47) {
    if (!new.target) { throw 'must be called with new'; }
}
F44.constructor;
[-65535n,v19,[-995267436,-8,-9n,-995267436,-65535n],v19,11n];
[-2147483649];
function F55(a57, a58) {
    if (!new.target) { throw 'must be called with new'; }
    function f59(a60, a61) {
        const v63 = ("0x2I").sup(F55, "0x2I", "0x2I", a61, f59);
        const v64 = v63.toString(F55, v63, a60, this);
        function F65(a67, a68) {
            if (!new.target) { throw 'must be called with new'; }
            this.g = v64;
        }
        const v70 = undefined ^ undefined;
        v70 * v70;
        return f59;
    }
    %PrepareFunctionForOptimization(f59);
    f59(F55, F55);
    %OptimizeFunctionOnNextCall(f59);
    f59(a58, a58);
}
new F55(F55, F55);
