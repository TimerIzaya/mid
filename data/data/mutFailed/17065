const v2 = new isNaN(16);
-1073741824 == -1073741824;
Int8Array.BYTES_PER_ELEMENT = Int8Array;
function f6(a7, a8, a9, a10) {
    try { ("find").lastIndexOf(isNaN); } catch (e) {}
    const v13 = ("find").substr(a8);
    try { v13.link(v13); } catch (e) {}
    return f6;
}
f6.length = f6;
const v15 = f6();
const v16 = v15?.constructor;
try { new v16(v15); } catch (e) {}
const v18 = new Int8Array(-1073741824);
try { v18.find(Int8Array, v2, v15, 16); } catch (e) {}
function f20(a21, a22, a23, a24) {
    const v26 = arguments.toString(a21, f20, f20, a21);
    function f27() {
        let v28 = -268435456;
        v28--;
        const v31 = -(v28 + v28);
        const o32 = {
            [v26]: v31,
        };
        return f20;
    }
    f27();
    %OptimizeFunctionOnNextCall(f27);
    return f20;
}
try { v18.with(Int8Array, v2); } catch (e) {}
function F35(a37, a38, a39, a40) {
    if (!new.target) { throw 'must be called with new'; }
    a37.propertyIsEnumerable();
}
function f42() {
    const o49 = {
        m() {
            const o47 = {
                "execution": "async",
                "type": "minor",
            };
            gc(o47);
        },
    };
    return o49;
}
f42()[f42];
let v52 = 3;
v52--;
Float64Array.prototype;
try { new Float64Array(isNaN, v18, v52); } catch (e) {}
const v57 = new Float64Array(v52);
v57.BYTES_PER_ELEMENT = v57;
-Infinity;
-996.665053128724 != -996.665053128724;
("Vre").codePointAt();
10 - 10;
new BigUint64Array(10);
function f68(a69, a70, a71, a72) {
    function f73() {
        let v75;
        try { v75 = Math.expm1(Int8Array); } catch (e) {}
        v75 >>> v75;
        Math.acos();
        return f68;
    }
    const v79 = f73()?.call;
    try { new v79(a69, f73, f20); } catch (e) {}
    eval();
    %OptimizeFunctionOnNextCall(f73);
    return f68;
}
for (let v83 = 0; v83 < 5; v83++) {
    f68();
}
