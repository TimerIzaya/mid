class C3 {
    static #m(a5) {
        const t2 = "n";
        t2[2] = a5;
        new Int8Array(1159);
        class C10 extends "bigint" {
            #m(a12, a13) {
                let [v15,v16,,v17] = this;
            }
        }
        try {
            a5.length = a5;
        } catch(e18) {
        }
        return "n";
    }
    static [C3];
    static #b;
    #e;
}
const v19 = new C3();
const t21 = "bigint";
const v20 = new t21();
const v21 = new C3();
function F22(a24, a25, a26, a27) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a25;
    Math.atan2(-Infinity, 536870887);
    for (let v32 = 0; v32 < 10; v32++) {
        const v33 = [-2.220446049250313e-16,0.4010936999061169];
        try {
            v33.length = -2;
        } catch(e35) {
        }
    }
    try {
        this.d = a25;
    } catch(e36) {
    }
}
const v37 = new F22("bigint", "bigint", v20, v19);
const v38 = new F22(v21, v37, v20, v21);
const v42 = new Float64Array(1000);
v42.includes(5);
new F22(v38, "bigint", v19, v38);
function f46(a47) {
    const o51 = {
        __proto__: 2,
        213: a47,
        ...a47,
        "g": 2,
        p(a49, a50) {
            return 2;
        },
    };
    return o51;
}
f46(2);
function F53() {
    if (!new.target) { throw 'must be called with new'; }
    const v58 = Array(19793);
    for (const v59 of v58) {
    }
    [[v58,v58,v58,v58]];
    ("function").normalize();
    const v65 = new Set();
    v65.values();
    [] >= Uint16Array;
}
%PrepareFunctionForOptimization(f46);
const v70 = f46();
%OptimizeFunctionOnNextCall(f46);
f46(v70);
