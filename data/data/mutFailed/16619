const o3 = {
};
o3.a = o3;
for (let v5 = 0; v5 < 5; v5++) {
    v5 / v5;
    v5 - v5;
    for (const v8 in "toString") {
    }
}
function f9() {
    const v13 = new BigUint64Array(4);
    function F14(a16, a17, a18) {
        if (!new.target) { throw 'must be called with new'; }
        this.a = a17;
    }
    const v19 = new F14(BigUint64Array, 4, v13);
    Object.defineProperty(v19, 241, { enumerable: true, value: 7 });
    return 63983;
}
const v20 = f9?.constructor;
let v21;
try { v21 = new v20(1000); } catch (e) {}
class C24 extends Float32Array {
}
const v25 = new C24();
const v27 = [v25,v25];
Reflect.apply(v25.reverse, v25, v27);
function F30(a32, a33, a34, a35) {
    if (!new.target) { throw 'must be called with new'; }
    try { a33.call(); } catch (e) {}
    for (let v37 = 0; v37 < 50; v37++) {
    }
}
try { new F30(1000, f9, 5, o3); } catch (e) {}
try { Uint32Array.of(); } catch (e) {}
new Int16Array(1971);
new BigUint64Array([BigUint64Array]);
Uint32Array.prototype = Uint32Array;
const v47 = new Uint32Array(5);
3 >> 3;
try { new Float64Array(v47, 5, Float64Array); } catch (e) {}
const v52 = new Float64Array(3);
v52[2] = v52;
const v55 = new Int32Array(3729);
v55[3149];
function f57() {
    return 3729;
}
try { new f57(); } catch (e) {}
function F60(a62, a63, a64, a65) {
    if (!new.target) { throw 'must be called with new'; }
    a63.caller = a65;
}
function f66(a67) {
    return f66;
}
try { new Float64Array(Float64Array, v21, Float64Array); } catch (e) {}
const v69 = new Float64Array();
for (const v70 in v52) {
    class C71 {
    }
    function F72(a74, a75, a76, a77) {
        if (!new.target) { throw 'must be called with new'; }
        a75.caller = a77;
    }
    function f78() {
        return F72;
    }
    try { v70.trimLeft(); } catch (e) {}
}
const v81 = /a(?!bbb|bb)c/vi.toString;
v81.name;
try { v81(); } catch (e) {}
const v85 = new WeakSet();
for (let v86 = 0; v86 < 25; v86++) {
    v85["p" + v86] = v86;
}
v69 > Uint32Array;
