const v0 = [];
function f1() {
    return v0;
}
function f2() {
    return f1;
}
function F6(a8, a9, a10) {
    if (!new.target) { throw 'must be called with new'; }
    const v11 = this?.__lookupGetter__;
    try { new v11(this); } catch (e) {}
    a9 >>> a9;
    a10--;
    try {
        this.b = a10;
    } catch(e15) {
    }
    try {
        this.a = a9;
    } catch(e16) {
    }
}
f1 != -65536;
const v22 = new F6(-65536, 2, -256);
v22.length = v22;
const v23 = new F6(2, 2, -65536);
const v24 = new F6(-65536, 2, 2);
1073741825 >>> 1073741825;
4 % 4;
class C30 extends f1 {
    static valueOf(a32, a33) {
        let v31 = this;
        %VerifyType(v23);
        ({"a":v31,...a32} = v24);
        return a32;
    }
    static #g;
    static [v22] = 4;
    static m(a38, a39, a40, a41) {
        super.d = v0;
        [9.119431074902462,2.0,1.1951587258277588e+308,2.0];
        [23.900765621619257,1000000000000.0,-3.0,5.0,1.0];
        [-158329.5212291897];
        return a38;
    }
}
const v45 = new C30();
const v46 = new C30();
const v47 = new C30();
const v48 = [];
new F6(v47, v24, 257);
const v51 = v45[v46];
let v52;
try { v52 = new v51(4); } catch (e) {}
v52[Symbol.split];
3 != 3;
class C59 {
    constructor(a61) {
        function* f62(a63, a64) {
            yield* v48;
            return a63;
        }
    }
    #m(a66, a67, a68) {
        try {
            v23.fuck(this, a66);
        } catch(e70) {
        }
        return this;
    }
}
