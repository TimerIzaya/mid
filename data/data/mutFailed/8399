new Uint8Array(6);
5 / 5;
const v6 = new Float32Array(5);
Uint8ClampedArray.e = Uint8ClampedArray;
new Uint8ClampedArray(Float32Array);
const v13 = new Uint8ClampedArray(5);
try { v13.join(undefined); } catch (e) {}
Int16Array.BYTES_PER_ELEMENT = Int16Array;
new Int16Array(0);
1 >> 1;
new Int8Array(1);
function f22() {
    return v13;
}
const v23 = f22.arguments;
function f24() {
    v6.c = Float32Array;
    ([2.0,-1e-15,1.7976931348623157e+308])[1];
    try { new Int16Array(Int8Array, Int8Array, 1); } catch (e) {}
    const v31 = new Int16Array(1371);
    (1351 % 1351).flat(1351);
    const v35 = v31.lastIndexOf(1371, 1351);
    for (let v36 = 0; v36 < 5; v36++) {
        const v37 = v36 & v36;
        v37.length;
        -2147483649 & -2147483649;
        const o42 = {
        };
        o42[Uint32Array] -= v35;
        class C44 {
        }
        try { C44.bind(Float32Array); } catch (e) {}
        const v48 = new BigUint64Array(10);
        try { v48.slice(v6, 0); } catch (e) {}
        Array(36862, v23, v37);
    }
    return f22;
}
%PrepareFunctionForOptimization(v23);
const v52 = f24();
%OptimizeFunctionOnNextCall(f24);
v52();
function F54(a56) {
    if (!new.target) { throw 'must be called with new'; }
    0 / 0;
}
