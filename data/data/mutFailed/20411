[536870888,10,-16,781337891];
const v1 = [127,817913402,9,-10,-6575,-14,9223372036854775807,-13489,-1145453093,5];
[58533,65535,257,127,-1443588520,8,-6,-772874471,536870889];
class C3 {
    #p(a5) {
        super[a5];
        const v8 = Symbol.iterator;
        const o17 = {
            [v8]() {
                let v10 = 10;
                const o16 = {
                    next() {
                        v10--;
                        const v14 = v10 == 0;
                        const o15 = {
                            "done": v14,
                            "value": v10,
                        };
                        return o15;
                    },
                };
                return o16;
            },
        };
        return this;
    }
}
const v18 = new C3();
function f19(a20) {
    const v22 = ("-15").anchor();
    const v24 = new Date();
    v24.setYear(v22);
    return v1;
}
v18[Symbol.toPrimitive] = f19;
const v28 = new C3();
const v29 = new C3();
new Set();
class C35 {
    get f() {
        v1[v1] ||= C3;
        Math.round(v29);
        this ^ v18;
        this / this;
        v18 | -1381536036;
        return Math.trunc(v29);
    }
    5;
    [v18] = v29;
    [11n] = v28;
    static #b = C3;
}
new C35();
new C35();
new C35();
const v47 = [];
function F51(a53, a54, a55, a56) {
    if (!new.target) { throw 'must be called with new'; }
    this.constructor = f19;
    a53.strike();
    const v58 = this.constructor;
    try { new v58(a56, v47, a54, a56); } catch (e) {}
    a54[2];
}
new F51("ceil", "pop", "ceil", "isConcatSpreadable");
