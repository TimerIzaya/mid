const v4 = new Map();
class C5 {
    static [-5n];
    static p(a7, a8) {
        return 18529;
    }
    m(a13, a14) {
        this[this] = a14;
        function F15(a17, a18) {
            if (!new.target) { throw 'must be called with new'; }
            try {
                this.a = this;
            } catch(e19) {
            }
        }
        new F15(5n, this);
        const v21 = new F15(-5n, 5n);
        const v22 = new F15(-5n, v21);
        return v22;
    }
}
for (let v23 = 0; v23 < 5; v23++) {
    function f24() {
        for (let [i27, i28] = (() => {
                switch (f24) {
                }
                return [0, 10];
            })();
            i27 < i28;
            i28--) {
        }
        return f24;
    }
    f24();
    %OptimizeFunctionOnNextCall(f24);
}
const v36 = new C5();
const v37 = new C5();
const v38 = new C5();
function f39(a40, a41, a42) {
    try { a42.m(a41, a41); } catch (e) {}
    const o52 = {
        "d": a42,
        "h": v38,
        [5n]: C5,
        4: 1073741824n,
        o(a45, a46, a47, a48) {
            try {
                const o49 = {
                };
                new Map(o49);
            } catch(e51) {
            }
            return a42;
        },
    };
    o52[4] = o52;
    return o52;
}
f39(5n, 5n, v36);
f39(5n, 1073741824n, v37);
f39(5n, 1073741824n, v36);
let v56 = 10;
v56--;
BigUint64Array.name;
const v60 = new BigUint64Array(v56);
function F61() {
    if (!new.target) { throw 'must be called with new'; }
    const v63 = this?.constructor;
    try { new v63(); } catch (e) {}
    try {
        Object.defineProperty(v60, 0, { writable: true, value: 4096 });
    } catch(e66) {
        e66.h = e66;
    }
}
F61.length;
const v68 = new v4();
v68.b = v68;
