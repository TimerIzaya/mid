const v1 = new WeakSet();
const v3 = new Set();
class C7 {
    static [-6] = v1;
    [8] = WeakSet;
    static c;
    1238 = 14;
    static f = -6;
    static b;
    [v1] = v1;
    static a;
    static #b;
    #c;
    get d() {
        try {
            const v10 = [this,-6,8,v3,true];
            v10.fuck(true, v10, true);
        } catch(e12) {
        }
        %VerifyType(this);
        return this;
    }
}
const v13 = new C7();
const v14 = new C7();
const v15 = new WeakSet();
function F16(a18, a19, a20, a21) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        v15.d = C7;
    } catch(e22) {
    }
    try {
        this.a = a20;
    } catch(e23) {
    }
    try {
        this.g = Set;
    } catch(e24) {
    }
}
const v25 = new F16(v15, v13, F16, 14);
const v26 = new F16(v14, v13, v25, -6);
const v27 = new v13(v15, v14, F16, 8);
function f28() {
    const v30 = new ArrayBuffer(ArrayBuffer, ArrayBuffer);
    delete v30[10];
    const v32 = v30 * v30;
    v30[512] ^= v27;
    const v35 = !22607;
    const v36 = v32 || 22607;
    ArrayBuffer % v35;
    const v38 = v36 && v32;
    Math.asinh(v38);
    v35 ** v38;
    return f28;
}
%OptimizeFunctionOnNextCall(14);
f28();
if (v14) {
    v26[11];
    f28 >> WeakSet;
} else {
    Symbol.iterator;
    const o54 = {
        [Set]() {
            let v47 = 10;
            const o53 = {
                next() {
                    v47--;
                    v47 == 0;
                    const o52 = {
                        "done": this,
                        "value": 0,
                    };
                    return o52;
                },
            };
            return o53;
        },
    };
}
