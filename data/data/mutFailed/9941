let v0 = [];
class C1 {
    static #o() {
        v0 ^ this;
        return v0;
    }
    #h;
    static m() {
        super.c;
        let {"b":v9,"f":v10,} = this;
        v0[v9] %= v10;
        let v11;
        try { v11 = v9.includes(v0, v10); } catch (e) {}
        let {"e":v12,...v13} = v11;
        v0 = v13;
        function f14() {
            return v0;
        }
        return this;
    }
}
const v15 = new C1();
const v16 = new C1();
new v16();
[-2.220446049250313e-16,5.0,-982814.8130498233,-674214.861500801];
const v19 = [226597.53244411387,206091.00150085264,-1000000.0,0.06651242756958409,-8.941271751100997];
const v20 = [NaN,1e-15,-926.2448249593584,0.8695153416054324,1000.0];
function F21(a23, a24) {
    if (!new.target) { throw 'must be called with new'; }
    const v25 = v19?.constructor;
    try { new v25(a24, v0); } catch (e) {}
    try {
        this.c = v19;
    } catch(e27) {
    }
}
const v28 = new F21(v0, v0);
v28.b = v28;
new F21(v15, v15);
new F21(v28, v20);
const v33 = ("-256")?.constructor;
let v34;
try { v34 = new v33("-256"); } catch (e) {}
2011 >= 2011;
const v40 = new v34(512);
v40.includes(2011);
