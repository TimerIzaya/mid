4 <= 731122.4801480968;
function f6(a7, a8, a9, a10) {
    const v11 = a8 >>> a8;
    (v11 >>> v11) != -256;
    for (let v14 = 0; v14 < 5; v14++) {
    }
    return -256;
}
const v16 = new Uint32Array(4);
65537 < 4096n;
const v20 = [58584,15,9007199254740990,2146023485];
const v21 = [46733,-268435456];
Object.defineProperty(v20, 65537, { writable: true, value: 100360.20583715336 });
let v22 = Uint32Array % 65537;
v22 ||= v22;
try { v21.toString(); } catch (e) {}
const v25 = Symbol.iterator;
const o34 = {
    [v25]() {
        let v27 = 10;
        const o33 = {
            next() {
                v27--;
                const v31 = v27 == 0;
                const o32 = {
                    "done": v31,
                    "value": v27,
                };
                return o32;
            },
        };
        return o33;
    },
};
const v37 = new Int8Array(5);
new Int16Array(4087);
[-515617499,9007199254740990,1794867738,-2147483647,4,8];
[1073741824,1155028686,-4,1022797559];
function F43(a45) {
    if (!new.target) { throw 'must be called with new'; }
}
const v46 = new Int16Array();
v46.g;
const t42 = -0.0;
t42.constructor = gc;
class C49 {
}
[];
const v51 = [];
new Map();
function F54(a56, a57) {
    if (!new.target) { throw 'must be called with new'; }
    const v58 = this.constructor;
    try { new v58(); } catch (e) {}
    const o61 = {
        0: v51,
        162: "1ya",
    };
}
const v62 = new F54();
const v64 = new Int32Array();
const v68 = new Uint8ClampedArray();
const v69 = new v16(3208);
const t63 = v64.constructor;
new t63(v68);
Int32Array.from(v69);
const v73 = new F54(Map, Map);
new F54(v62, v73);
let v75 = 16;
v75--;
const v78 = new Int8Array(v75);
v78.toSorted();
const o84 = {
    ...gc,
    5: 65536,
    __proto__: Int8Array,
    valueOf(a83) {
        return a83;
    },
    "g": 65536,
    163: v37,
};
