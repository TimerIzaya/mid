new Uint32Array(2899);
let v3 = 260;
const v5 = new Int16Array(v3);
const v8 = new Float64Array(64);
class C9 extends Uint32Array {
    static m(a11, a12, a13, a14) {
        let v15 = 9;
        function F16(a18, a19, a20) {
            if (!new.target) { throw 'must be called with new'; }
            v15++;
        }
        function f22() {
            for (let v23 = 0; v23 < 5; v23++) {
                const v24 = new F16();
                function F25(a27, a28) {
                    if (!new.target) { throw 'must be called with new'; }
                }
                new F25();
                const v31 = v15 ** v15;
                const v32 = !v15;
                9007199254740991 * v31;
                v32 % F16;
                const t20 = v24.constructor;
                new t20();
            }
        }
        %PrepareFunctionForOptimization(f22);
        f22();
        %OptimizeFunctionOnNextCall(f22);
        f22();
        this[Uint32Array];
        function f40() {
            return 64;
        }
        Float64Array && this;
        return 64;
    }
    6;
    [-2] = v8;
    static {
        for (const v43 in v5) {
            v5[2899] += 2899;
            v3 %= 2899;
            const o44 = {
            };
            new Proxy(this, o44);
        }
    }
}
new C9();
new C9();
new C9();
new Uint8Array(24);
new Float64Array(631);
new Int8Array(5);
function F60() {
    if (!new.target) { throw 'must be called with new'; }
}
new Int8Array(268435456);
[F60,Uint8Array];
