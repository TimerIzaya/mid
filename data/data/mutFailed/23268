const t0 = [-936145422,536870912,127,257,-36772,-15984,2];
t0.length = 6;
function f3(a4, a5) {
    return a5;
}
new Promise(f3);
class C10 {
    b = 1;
    constructor(a12, a13) {
        let v11 = this;
        a13 = 1;
        function F18(a20, a21, a22, a23) {
            if (!new.target) { throw 'must be called with new'; }
            const v24 = this.constructor;
            let v25;
            try { v25 = new v24(a20, a23); } catch (e) {}
            typeof v25 === "symbol";
        }
        const v29 = new F18(65537, 1073741824, 0.19443453377416953, F18);
        new F18(Date, 0.19443453377416953, a13, v29);
        function f33(a34, a35, a36, a37) {
            return 1;
        }
        Symbol.for(Symbol.toPrimitive.description);
        const v43 = -(-14);
        +v11;
        ++v11;
        Math.sinh(1831999511);
        +v11;
        Math.cos(-14);
        ~v43;
    }
}
const v50 = new C10(1, C10);
const v51 = new C10(1831999511, 1);
const v52 = new C10(1831999511, 1);
function F53(a55, a56) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.c = C10;
        function f57() {
            return a55;
        }
        const v60 = new BigUint64Array(4096);
        v60.includes(4096);
    } catch(e62) {
    }
}
const v65 = 1940694780n ^ 1940694780n;
function F66(a68, a69) {
    if (!new.target) { throw 'must be called with new'; }
    this.constructor;
    try { new a69(); } catch (e) {}
    -a68;
}
new F66(Float32Array, v65);
new F53(v50, v50);
const v75 = new F53(v52, v50);
new F53(v52, v52);
for (let v79 = 0; v79 < 89; v79++) {
    const v80 = new C10(1831999511, v79);
    v80.b;
}
try { v51["findIndex"](536870888, 10000, 1831999511, "findIndex", v50); } catch (e) {}
function f85() {
    const o86 = {
    };
    const v87 = o86.constructor;
    v75();
    return v87;
}
%PrepareFunctionForOptimization(f85);
f85();
%OptimizeFunctionOnNextCall(f85);
f85();
