const v0 = [-1.0];
v0[6] = v0;
const v1 = [-2.4006529591729686,-797.9572729457966,-1.7976931348623157e+308,-2.2250738585072014e-308];
const v2 = [1000.0,-789717.8131863867,1.3998999098993553e+308,-1000000000000.0,-1.338730659976497e+308,223312.96248885663,-2.0,0.08789144014620809,0.0,1.2293107879950824];
v2[14] = v1;
function f3(a4) {
    a4[7] = a4;
    const o21 = {
        11: v2,
        "c": a4,
        ...a4,
        __proto__: v2,
        ...v2,
        [v2](a6) {
            const v9 = new Float64Array(89);
            for (const v12 in v2) {
                f3(v9);
                %PrepareFunctionForOptimization(f3);
                f3(v9);
                f3(v9);
                %OptimizeMaglevOnNextCall(f3);
                f3(v9);
            }
            new Uint32Array(1);
            const v20 = new BigUint64Array(2705);
            return v20;
        },
    };
    o21[0];
    return o21;
}
f3.toString = f3;
const v23 = f3?.constructor;
let v24;
try { v24 = new v23(v2); } catch (e) {}
const v25 = f3(v2);
v25.valueOf = f3;
const v26 = f3(v1);
v26[Symbol.toPrimitive] = f3;
const v29 = f3(v0);
Object.defineProperty(v29, "toString", { writable: true, configurable: true, value: f3 });
function f30(a31, a32, a33) {
    a31[5] = v24;
    function f34(a35) {
        try { new a33(a31, a35, a33, a32, a35); } catch (e) {}
        Math.__defineSetter__;
        return a35;
    }
    a32[Symbol.toPrimitive] = f34;
    const v41 = a31?.filter;
    const v42 = v0[2147483648];
    let v43 = v2.splice(a32, v29, v29, a33, a32);
    v24 instanceof v24;
    v43 = v2;
    function F45(a47, a48, a49, a50) {
        if (!new.target) { throw 'must be called with new'; }
        this.h = v1;
        try {
            this.f = v41;
        } catch(e51) {
        }
        try {
            this.h = a49;
        } catch(e52) {
        }
    }
    const v53 = new F45(f30, v43, a33, v43);
    new F45(v42, v0, v29, v43);
    new F45(v1, v0, v42, v1);
    let v56;
    try { v56 = new v41(a31); } catch (e) {}
    const o64 = {
        [v26](a58, a59) {
            a59 ||= a59;
            let v60;
            try { v60 = a31(a59, this, this, a58, v0); } catch (e) {}
            try {
                const o61 = {
                };
                v26.fuck(v60, v26, f3, o61);
            } catch(e63) {
            }
            return v25;
        },
        [f3]: v0,
        __proto__: v53,
        ...v29,
        "d": v1,
        "g": v2,
        112: a32,
        7: a33,
        /*
        __proto__: v25,
        */
        "b": v26,
        10: v56,
        "g": v25,
        "c": v24,
        "f": a33,
    };
    return o64;
}
f30(v0, v25, v0);
f30(v1, v29, v2)[112];
f30(v25, v25, v1);
const v70 = new Map();
try { v70.forEach(v2); } catch (e) {}
[1000000000.0,0.5862539335295323,0.5597483213227774,-1000000.0,-3.0,-3.0,-614972.1916769096,-Infinity];
const v74 = ([-7.770964501688567e+307,-3.0,-2.0,1000.0,2.220446049250313e-16,5.341188966171874e+307,-2.220446049250313e-16,-3.0,1000.0])?.filter;
try { new v74(v25); } catch (e) {}
[-2.220446049250313e-16,-Infinity,-1.100634047348919,-1e-15,-4.008159040612802];
v1[4] >>>= v24;
Reflect.construct(Uint8Array, [v24], Uint8Array);
function F81(a83, a84) {
    if (!new.target) { throw 'must be called with new'; }
    function f85(a86, a87) {
        const v89 = new Uint8Array(Uint8Array, Uint8Array, Uint8Array);
        const v90 = a86++;
        const v91 = a86 % a86;
        const o92 = {
            ...v89,
        };
        let v93;
        try { v93 = o92.n(v91, v90); } catch (e) {}
        return v93;
        return v90;
    }
    a84[Symbol.toPrimitive] = f85;
    const v96 = a83?.constructor;
    try { new v96(a83); } catch (e) {}
    a84.arguments;
}
const v99 = new F81(F81, F81);
v99.f = Symbol;
v99.f = v99;
Math.asinh(~v99);
