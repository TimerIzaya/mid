Int32Array.bind().name;
function F7(a9, a10, a11, a12) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = Date;
}
const v15 = new Uint8ClampedArray(7);
new Uint8Array(127);
for (let i23 = 0, i24 = 10; i23 < i24; i23++) {
}
const v31 = new Float32Array(4096);
class C32 extends Float32Array {
    constructor(a34, a35) {
        super(a35, a35, 7);
        for (const v36 in this) {
            try {
                v15.g = 4096;
            } catch(e37) {
                v36.arguments = v36;
                function F38() {
                    if (!new.target) { throw 'must be called with new'; }
                    try {
                        for (let v40 = 0; v40 < 50; v40++) {
                            for (let v41 = 0; v41 < 25; v41++) {
                                this["p" + v41] = v41;
                            }
                        }
                    } catch(e44) {
                    }
                }
            }
        }
    }
    a = -2147483648;
    n(a46, a47, a48, a49) {
        super[Uint8Array];
        return v31;
    }
    static 10;
}
new C32(6, -2147483648);
new C32(4096, -6);
new C32(4096, 127);
const v55 = new Int16Array(Int16Array, Int16Array, Int16Array);
function f56() {
    return f56;
}
class C57 extends f56 {
    constructor(a59, a60, a61, a62) {
        super();
        function f63() {
            const o64 = {
                "g": a60,
                ...v55,
            };
            return C57;
        }
        for (let v65 = 0; v65 < 5; v65++) {
            f63();
            %OptimizeFunctionOnNextCall(f63);
        }
    }
}
new C57();
