const v2 = new Int32Array(2);
const v5 = new BigUint64Array(7);
const v8 = new Float64Array(1024);
function F9(a11, a12, a13, a14) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.h = a14;
    } catch(e15) {
    }
}
const v16 = v2.byteOffset;
v5["findIndex"](v16, v16, ...v8, ...v8, ..."findIndex", 1024);
let v20;
try { v20 = v5["forEach"](v16, ...7, BigUint64Array, ...v2, ..."forEach", BigUint64Array); } catch (e) {}
const v21 = new F9(7, 1024, 7, 1024);
const v22 = new F9(1024, 7, 2, 1024);
new F9(1024, 2, 2, 7);
class C24 {
    get d() {
        try { v20(v21); } catch (e) {}
        try {
            this.b = Float64Array;
        } catch(e27) {
        }
        2079041347 * this;
        2079041347 / 2147483649;
        !2147483649;
        return v8;
    }
    static #m(a35, a36) {
        class C38 extends v22.constructor {
            static c = v8;
        }
        new C38();
        return F9;
    }
}
new C24();
const v41 = new C24();
new C24();
class C43 {
}
const v44 = new C43();
const v47 = new Uint32Array(4);
class C48 {
}
v41 & (252988655 + v41);
v41 * v47;
Math.acosh(v47);
Math.expm1(252988655);
try { C48.apply(v44, v47); } catch (e) {}
