function f0() {
    const o24 = {
        toString(a5) {
            async function f6(a7, a8, a9) {
                return a7;
            }
            const v10 = /((((.).).).)?/gvdimy;
            const v11 = /C/gudm;
            let v13;
            try { v13 = Uint32Array(Uint32Array, -1489157957, v10); } catch (e) {}
            for (let i15 = 0; i15 < 6; i15++) {
                try {
                    v11.dotAll = v13;
                } catch(e21) {
                }
            }
            const v22 = a5 | "9";
            this[this];
            return v22;
        },
        "a": -1489157957,
        4: 14992,
        "g": 14992,
        __proto__: "9",
        "f": 14992,
    };
    return o24;
}
const v25 = f0();
const v26 = f0();
const v27 = f0();
function f28(a29, a30) {
    const o31 = {
        ...a30,
        "g": a29,
        2: f0,
        [f0]: a30,
        536870912: a29,
        "e": v25,
        __proto__: a30,
        "c": v26,
        6: f0,
        "f": a29,
    };
    return o31;
}
f28(v25, v27);
f28(v27, v25);
f28(v27, v26);
/a{12z}+/dimy;
/(?:a{5,1000000}){3,1000000}a(?!b)*/gvms;
function F38() {
    if (!new.target) { throw 'must be called with new'; }
    for (let v40 = 0; v40 < 500; v40++) {
        const v45 = ("p" + v40).fontcolor(v40).trimLeft()[12];
        ("p")[v45.substring(v45, v45)];
    }
}
/l(ab)/gvim;
function f49() {
    const v52 = [8n,8n,8n,8n] > 8n;
    let v53 = 0;
    function f54() {
        return f54;
    }
    const v55 = [-4];
    try {
        new BigUint64Array(v55);
    } catch(e58) {
    }
    for (let v59 = 0; v59 < 5; v59++) {
        TypeError();
        new Int32Array(Int32Array);
        for (let v66 = 0; v66 < 10; v66++) {
            Array(36862);
        }
        Array(36862);
    }
    while (v53 < 10) {
        for (let v73 = 0; v73 < 5; v73++) {
            "n" + v73;
        }
        v53++;
    }
    return v52;
}
%PrepareFunctionForOptimization(f49);
f49();
%OptimizeFunctionOnNextCall(f49);
f49();
