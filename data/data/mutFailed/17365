const v0 = [-3.0,1.2856637196728047e+308,-836561.9131612226,-402.5612917170988];
const v1 = [-5.0,1.0,0.6019751056739164,2.220446049250313e-16,0.47720018768595507];
const v3 = [[-1000000000.0,0.48274020679383967],v1,v1,v0];
const v4 = [v3,v3];
v4[1] = v4;
[v4];
~5n;
[268435439,-10,13238];
[-2147483649,-3846,536870889,-1];
[-65537];
new Int8Array(1438);
-3153;
const v19 = new BigInt64Array(3153);
v19[206];
4096 - 4096;
const v24 = new Float64Array(4096);
function f25() {
    for (let v26 = 0; v26 < 5; v26++) {
        v26++;
        -(v26 / v26);
        function f30() {
            return f25;
        }
        try { f30.call(4096); } catch (e) {}
    }
    return f25;
}
%PrepareFunctionForOptimization(f25);
f25();
%OptimizeFunctionOnNextCall(f25);
function F34(a36) {
    if (!new.target) { throw 'must be called with new'; }
}
const v38 = new F34("4294967297");
const v39 = [Infinity,1.0,-1.2272545370579378e+308,-1000000.0,5.0,1.7976931348623157e+308,5.0];
function F40() {
    if (!new.target) { throw 'must be called with new'; }
    try {
        Array(19793);
        [[]] >= Uint16Array;
    } catch(e49) {
        v39.findLastIndex;
    }
}
new F40();
try { Set.bind(v38); } catch (e) {}
new Set();
1000 - 1000;
const v58 = new Uint8Array(1000);
const v62 = Array();
try { v62.findLast(v62); } catch (e) {}
const v66 = Array(1000);
v66[928] = v24;
let v67;
try { v67 = v66.push(1000); } catch (e) {}
const v68 = new BigUint64Array(257);
const v69 = Uint8Array in v68;
v69 && v69;
try {
    for (let v72 = 0; v72 < 100; v72++) {
        Array(v67);
    }
    v68.d = v58;
} catch(e74) {
}
function f77(a78) {
    a78++;
    -2.0;
    ++f25;
    -6 ^ f25;
    return a78;
}
Object.defineProperty(Float32Array, "constructor", { configurable: true, enumerable: true, value: f77 });
const v86 = new Float32Array(4);
function f87(a88) {
    gc(128n);
    return f77;
}
Object.defineProperty(v86, "valueOf", { writable: true, value: f87 });
v86[3] = v86;
Uint8Array.e = ~4096;
Uint8Array.name;
Uint8Array.e = Uint8Array;
const v98 = Float32Array?.constructor;
try { new v98(v66); } catch (e) {}
const v100 = Float32Array.name;
v100?.toLocaleUpperCase;
function f103() {
    return f103;
}
let v104 = -2n;
v104--;
function f107() {
    return 536870887n;
}
try { f107(); } catch (e) {}
let v109;
try { v109 = f107(); } catch (e) {}
v109 * v109;
let v111 = 2;
v111++;
Map.prototype;
Uint8Array.prototype = Uint8Array;
function F118() {
    if (!new.target) { throw 'must be called with new'; }
    const v121 = Date();
    try { v121.small(); } catch (e) {}
    const v125 = Array(19793);
    v125[18326] = 141;
    for (const v126 of v125) {
    }
    try {
    } catch(e127) {
    }
}
const v128 = new F118();
const v129 = v128?.constructor;
try { new v129(); } catch (e) {}
function F131(a133, a134, a135) {
    if (!new.target) { throw 'must be called with new'; }
    for (let i138 = 0, i139 = 10;
        (() => {
            const v140 = i138 < i139;
            const v141 = [127,506635944,-9223372036854775808,5,-536870912,-12000821,2147483649];
            try {
            } catch(e142) {
            }
            const v143 = v141.toSpliced();
            v143[3] = v143;
            return v140;
        })();
        ) {
    }
}
const v151 = Array(4087);
v151[2101] = v100;
for (const v152 of v151) {
}
class C153 {
    constructor(a155) {
        try {
        } catch(e156) {
        }
        try {
        } catch(e157) {
            class C158 extends Map {
            }
        }
        for (const v159 of "bigint") {
        }
    }
}
C153.toString = f103;
const v160 = C153?.toString;
try { new v160(); } catch (e) {}
class C162 extends C153 {
}
const o163 = {
};
f25();
