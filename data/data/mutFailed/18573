class C3 {
    c = NaN;
    toString(a5) {
        super.a ^= a5;
        try {
            this.fuck(a5, false, a5, -62111);
        } catch(e9) {
        }
        return -5.73611034476378e+307;
    }
    #d = 0.4815171082008085;
    static e = 0.4815171082008085;
}
const v10 = new C3();
const v11 = new C3();
const v12 = new C3();
new Array(7);
class C16 extends Array {
    10 = v10;
    constructor(a18, a19) {
        super(7);
        const t21 = 7;
        t21[3] = Array;
        super[0.4815171082008085] = a18;
        0.4815171082008085 | a19;
    }
    #m(a22, a23, a24) {
        try {
            v11.a = a23;
        } catch(e25) {
        }
        [7,a24,v10,[7],a22];
        [v11];
        return a22;
    }
}
new C16(NaN, v11);
new C16(-5.73611034476378e+307, v12);
new C16(NaN, v10);
class C32 {
    constructor(a34, a35) {
        let v36 = 10;
        for (let i = 0; i < 5; i++) {
            const v37 = v36--;
            function f38(a39, a40, a41, a42) {
                const v44 = new Int16Array();
                async function f46(a47, a48, a49) {
                    for (const v50 of a34) {
                        -740089575 ^ v36;
                    }
                    await v44[1];
                }
                f46().finally(Uint8Array);
                return v37;
            }
            for (let v57 = 0; v57 < 5; v57++) {
                f38();
            }
            %OptimizeFunctionOnNextCall(f38);
        }
    }
}
new C32(C32, C32);
function f60() {
    const v63 = Array(4087);
    v63[4037] = v63;
    for (const v64 of v63) {
    }
    return Array;
}
%PrepareFunctionForOptimization(f60);
f60();
%OptimizeFunctionOnNextCall(f60);
f60();
