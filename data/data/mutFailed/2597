[1073741825n,2.0,1000000000000.0,[1000000000000.0,1073741825n]];
const v11 = [-377740816n,2.0,-1423668006n,1073741825n,0.715037720231114];
const v17 = [1000000000.0,2.2250738585072014e-308,-3.0,-2.2250738585072014e-308,-2.2250738585072014e-308,-6.525028373249204e+307,-7.851646360254072e+307,0.6785915059434757,-0.0];
class C18 {
}
C18[Symbol.replace] = v17;
const t6 = 5;
const v22 = new t6();
-642098.7657815786 & v22;
function F24(a26, a27, a28) {
    if (!new.target) { throw 'must be called with new'; }
    a27.toString();
}
function F33(a35, a36, a37, a38) {
    if (!new.target) { throw 'must be called with new'; }
    const v39 = this.constructor;
    try { new v39(); } catch (e) {}
    typeof Float32Array;
}
new F33();
function F44(a46, a47) {
    if (!new.target) { throw 'must be called with new'; }
    const v48 = this?.constructor;
    try { new v48(0.29489550717955537, a46); } catch (e) {}
    try { this.constructor(0.6822080711934364, this); } catch (e) {}
    try {
        let v51 = 2;
        const v52 = v51++;
        function f53(a54) {
            const o58 = {
                __proto__: v51,
                213: a54,
                p(a56, a57) {
                    return v52;
                },
            };
            return o58[213];
        }
        f53(v52);
        %OptimizeFunctionOnNextCall(f53);
        this.f = 3.0;
    } catch(e61) {
    }
}
new F44("string");
new F44();
function F65() {
    if (!new.target) { throw 'must be called with new'; }
    const v67 = this.constructor;
    let v68;
    try { v68 = new v67("string", "string", v67, v67); } catch (e) {}
    const v69 = this.valueOf(F65);
    switch (v11) {
        case "string":
            v69 < v68;
            break;
    }
}
3911 >> 3911;
new Int32Array();
class C79 {
    constructor() {
        const v81 = this.constructor;
        try { new v81(); } catch (e) {}
        super.f >>= this;
    }
}
