const v1 = new Map();
class C2 {
    constructor(a4) {
        v1[this] = Map;
        try { v1.forEach(a4); } catch (e) {}
    }
    toString(a7, a8) {
        /Zfoo|(bar|baz)|quux/dis;
        const v10 = /\xe2\x81\xa3/gudms;
        /zRxyz{93}/vm;
        return v10;
    }
}
new C2(v1);
const v14 = new C2(Map);
const v15 = new C2(v14);
const v16 = [11,-10,-9223372036854775808];
v16[v16] = C2;
try { v14(v15, v14, Map, C2, v16); } catch (e) {}
const v20 = v14[2]?.h?.[C2];
[-2147483647,129,536870912];
[32607,-4,-6,9007199254740992,6,1073741824,1905577154,2063032835,-1024];
new Date();
function f31() {
    return "NaN";
}
class C32 {
    set f(a34) {
        const o35 = {
            "d": "reduce",
            "c": Date,
            "f": a34,
            "g": a34,
            "a": a34,
            597679773: a34,
        };
    }
    constructor(a40, a41) {
        const v42 = [this,Date,this];
        [v42];
        [Date,"string",v42];
        ("NaN").length;
    }
}
new C32("NaN", "NaN");
const v48 = new C32(f31, "reduce");
new C32("reduce", v48);
let v53 = 0;
while (v53 < 5) {
    try {
        Date();
    } catch(e57) {
    }
    Date[Date];
    /3\u0060/gvs;
    /ab|c/vdms;
    /a\w\11(?<a>.)\k<a>/gd;
    const o62 = {
    };
    v53++;
}
class C64 extends C32 {
    static d = 9007199254740992;
    323 = 3;
    valueOf(a66, a67, a68, a69) {
        for (let v70 = 0; v70 < 32; v70++) {
            Date["p" + v70] = v70;
        }
    }
    e;
    [9007199254740992];
}
C64.d;
for (let v75 = 0; v75 < 32; v75++) {
    Date["p" + v75] = v75;
    +v75;
    try { ("number").trimStart(); } catch (e) {}
}
new C64();
new C64();
("boolean").repeat(1000000.0);
function f89(a90, a91) {
    const o94 = {
        set d(a93) {
        },
    };
    const v97 = new Int8Array(268435456);
    return v97;
}
for (const v98 in "NaN") {
    v20[536870888] = v1;
    try {
        new C32(-38457n, -38457n);
    } catch(e101) {
    }
}
