new Set();
[-10,-9007199254740991,-920980841,-9,-14,16];
[16,4294967297,-16];
[5,-536870912,5,257,15,12518,-43408,-9223372036854775808];
const v11 = [104762.14753807266,-279097.1642774454,5.0,1.0];
const v12 = [2.220446049250313e-16,0.4676436969349189,1.5179111745363469e+308,-1000.0,-2.220446049250313e-16,-1000000000000.0,4.0,4.587029279807309,-0.0];
const v17 = new Uint8Array(22);
const v20 = new Int32Array(3289);
const v22 = [v20];
class C25 extends Reflect.apply(v11.join, v17, v22) {
    [Set] = true;
    [v12];
}
new C25();
let v1 = -3;
class C3 {
    static toString(a5, a6) {
        a5[1] += v1;
        a5?.[6];
        return C3;
    }
    get e() {
        try {
            super.h = this;
        } catch(e9) {
        }
        try {
            v1 |= -268435456;
        } catch(e10) {
        }
        return this;
    }
}
C3.length = C3;
new C3();
v1?.constructor;
let v13;
try { v13 = new v1(); } catch (e) {}
v13.b = v13;
const v14 = new C3();
const v15 = (6)?.__lookupGetter__;
try { new v15(v13); } catch (e) {}
new C3();
try { ("p").padEnd(v14); } catch (e) {}
C3[2] = "40089";
function F22() {
    if (!new.target) { throw 'must be called with new'; }
    const v24 = this?.constructor;
    try { new v24(); } catch (e) {}
}
const v26 = new F22();
const v27 = v26?.constructor;
try { new v27(); } catch (e) {}
try { new v27(); } catch (e) {}
v27[-1];
let v32;
try { v32 = Math.acosh(Math); } catch (e) {}
v32 - v32;
1.7976931348623157e+308 & 1.7976931348623157e+308;
Math.log1p(+1.7976931348623157e+308);
