const v2 = new Float64Array(1173);
new Float32Array(479);
const v8 = new Float64Array(3);
function F9(a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
    a12 >>> a12;
    try {
        this.f = a12;
    } catch(e15) {
    }
}
F9.d = F9;
new F9(1173, 479, 479);
function f17(a18, a19, a20) {
    a18++;
    a18 >> 45754;
    const v27 = a18 << 479;
    ~479;
    -8.438423679748928 / v27;
    return v2;
}
F9(F9, 1173, 1173);
const v31 = new F9(1173, v8, 479);
new F9(1173, v31, 3);
function F33(a35, a36) {
    if (!new.target) { throw 'must be called with new'; }
    try { this.constructor(v2, a36); } catch (e) {}
}
const v38 = new F33();
v38?.constructor;
try { new f17(1173, 1173); } catch (e) {}
function f41() {
    return v2;
}
try { f41(); } catch (e) {}
const v43 = /{}(x)(x)(x)\4*a{0}a|b/msy;
const v46 = new BigUint64Array();
try { v46.entries(); } catch (e) {}
function F48(a50, a51, a52) {
    if (!new.target) { throw 'must be called with new'; }
    this.__proto__;
    a51.BYTES_PER_ELEMENT = a52;
    const v54 = this.constructor;
    try { new v54(BigUint64Array, v46, v46); } catch (e) {}
    a52[1];
    function f58(a59, a60) {
        a60 / a60;
        arguments[1];
        arguments.toString = a59;
    }
    try { f58(f41, v43); } catch (e) {}
    f58(v54, 8077n);
}
const v66 = new F48(BigUint64Array, 4, v46);
const t54 = v66.constructor;
new t54(v38, v38, v43);
