class C3 {
    #m(a5, a6) {
        let v8 = -287339146;
        +v8;
        v8--;
        const v11 = Math.cosh(9007199254740990);
        this + v8;
        return v11;
    }
    1;
    f = 16;
    static 4 = 9007199254740990;
}
try { new C3(); } catch (e) {}
new C3();
new C3();
const v16 = new C3();
let v19 = 8;
v19++;
class C24 {
}
let v25;
try { v25 = C24.bind(C3); } catch (e) {}
const v26 = new C24();
const v27 = v26?.constructor;
try { new v27(); } catch (e) {}
function f29(a30) {
    let v31;
    try { v31 = a30.codePointAt(v16); } catch (e) {}
    const v32 = [];
    try { v32.every(v31); } catch (e) {}
    return [v32];
}
const v35 = f29?.__lookupSetter__;
try { new v35(v16); } catch (e) {}
v26[Symbol.toPrimitive] = f29;
class C40 {
}
function F41() {
    if (!new.target) { throw 'must be called with new'; }
}
const v43 = F41?.apply;
try { new v43(6, 9007199254740990); } catch (e) {}
const v45 = new F41();
const v46 = v45?.__lookupGetter__;
try { new v46("l7VK"); } catch (e) {}
[-207.12380510118123,-982114.0356244294,0.9612192807513333,-3.0,-1000.0,1.0];
const v50 = 9007199254740991n * 9007199254740991n;
for (let v51 = 0; v51 < 5; v51++) {
    function f52() {
        for (let v53 = 0; v53 < 5; v53++) {
            v53 * v53;
            "p" == "p";
            try { ("p").substring(C40, C40); } catch (e) {}
        }
        try {
            v46.forEach();
        } catch(e59) {
            try { e59.toString(); } catch (e) {}
            e59.a = f52;
            e59.a = v45;
            e59.a = e59;
        }
        const v62 = ("1073741824").constructor;
        function F63(a65, a66, a67, a68) {
            if (!new.target) { throw 'must be called with new'; }
        }
        class C70 extends Date {
        }
        v62.name = v62;
        const v71 = v62(v50);
        try { v71.replaceAll(6, v26); } catch (e) {}
        return "0";
    }
    v25();
    %OptimizeFunctionOnNextCall(f52);
}
