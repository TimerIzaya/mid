[-162.10600693715935,0.028609171918319354,2.0];
const v4 = [-2.013319961660091,-969055.6965177453,-4.0,0.23246633574828712,-155668.52465214278,Infinity,2.220446049250313e-16];
const v5 = [-598.6803780458647,-Infinity,8.550439672241112,-369699.6165768864,1.7976931348623157e+308,-2.220446049250313e-16,4.136217710408198,810804.6429408737];
function F6(a8, a9, a10, a11) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.f = a11;
    } catch(e12) {
    }
    new Uint8Array(-128);
    class C15 {
    }
    class C16 extends C15 {
    }
    const v17 = new C16();
    Reflect.isExtensible(v17);
}
new F6(-128, v4, 1287181766, v5);
new F6(257, v5, -128, v5);
for (let v22 = 0; v22 < 500; v22++) {
    class C24 {
    }
    const v27 = new Int32Array(v22, v22, 257);
    let v29 = new Map();
    [...v29] = v27;
}
new F6(1287181766, v5, -128, v4);
[255,755115468,13,64,4294967297,-36698,-256,16,-9223372036854775807];
[10,1073741823,41509,-15,12,52980,5,5,2147483647];
[-8];
const v39 = new Int32Array(257);
v39.reverse();
Symbol.for(Symbol);
const v45 = new Uint32Array();
Object.defineProperty(v45, "constructor", { writable: true, configurable: true, enumerable: true, value: Symbol });
let v46 = -4294967297n;
const v47 = v46--;
function f48(a49, a50, a51, a52) {
    const v53 = a49.keys;
    try { v53(); } catch (e) {}
    function f55() {
        return f55;
    }
    a49.constructor = f55;
    const t44 = a49?.constructor;
    const v57 = t44();
    const o65 = {
        [v46](a59, a60, a61, a62) {
            eval();
        },
    };
    new Array(v57);
    const v69 = new Int8Array();
    const v71 = v69.buffer.slice(v53, v57);
    try { v71.slice(v47); } catch (e) {}
    return f55;
}
for (let v73 = 0; v73 < 10; v73++) {
    f48(v45);
}
%OptimizeFunctionOnNextCall(f48);
f48(5);
