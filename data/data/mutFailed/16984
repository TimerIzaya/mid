new Float32Array(970);
new Uint16Array(1693);
new Uint8Array();
const v10 = new Int16Array(Int16Array, Int16Array, Int16Array);
function f11() {
    return f11;
}
class C12 extends f11 {
    constructor(a14, a15, a16, a17) {
        super();
        function f18() {
            const o19 = {
                "g": a15,
                ...v10,
            };
            return C12;
        }
        for (let v20 = 0; v20 < 5; v20++) {
            f18();
            %OptimizeFunctionOnNextCall(f18);
        }
    }
}
const v25 = new BigInt64Array(3329);
function f26(a27, a28) {
    return 3329;
}
const v31 = [v25];
const o32 = {
    "arguments": v31,
    "type": "function",
};
Worker(f26, o32);
const v34 = new Int16Array(3);
function F35(a37, a38, a39) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a38;
    this.d = this;
    this.g = F35;
    try {
        this.g = a39;
    } catch(e40) {
    }
    Symbol.toPrimitive;
    const v45 = new Uint32Array();
    const o49 = {
        n(a47, a48) {
            v45[2] = v45;
            return 2;
        },
    };
    try { o49.n(); } catch (e) {}
    try {
        this.h = v34;
    } catch(e51) {
    }
    try {
        this.d = 3;
    } catch(e52) {
    }
}
new F35(3, 3, 3);
new F35(1693, 970, 970);
new F35(3, 1693, 1693);
function F56(a58, a59, a60) {
    if (!new.target) { throw 'must be called with new'; }
    function f61(a62, a63, a64, a65) {
        return arguments;
    }
    const o67 = {
    };
    Object.defineProperty(this, "e", { configurable: true, enumerable: true, value: a59 });
    const v70 = new Uint16Array(96);
    new Float64Array(v70);
    this.e = a59;
    try {
        this.e = a59;
    } catch(e73) {
    }
    try {
        this.a = a59;
    } catch(e74) {
    }
}
new F56(1693, 1693, 970);
new F56(1693, 3, 1693);
new F56(970, 1693, 3);
new Date("2");
