let v1 = 2.0;
function F3(a5, a6) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.c = a6;
        for (const v7 of a5) {
            try { v7(v7, v7, a6, v7); } catch (e) {}
            v1 **= Infinity;
            try {
                const o9 = {
                };
                this.fuck(o9, 60508n, a6);
            } catch(e12) {
            }
        }
    } catch(e13) {
        const v14 = this[792];
        try {
            this.fuck([a5,v1,e13,v14,a6], Infinity);
        } catch(e17) {
        }
    }
    const v18 = a6?.[1];
    v18[F3] = v18;
    const v19 = a6 & F3;
    try { a6(v19); } catch (e) {}
    const v22 = Symbol.iterator;
    const o31 = {
        [v22]() {
            let v24 = 10;
            const o30 = {
                next() {
                    v24--;
                    const v28 = v24 == 0;
                    const o29 = {
                        "done": v28,
                        "value": v24,
                    };
                    return o29;
                },
            };
            return o30;
        },
    };
}
new F3(Infinity, Infinity);
const v33 = new F3(v1, Infinity);
const v34 = new F3(v1, v1);
[Infinity,v33,v34];
[1,-2.220446049250313e-16];
[1,Infinity,1,v1];
function f41() {
    const v43 = new Set();
    v43.add(v43);
    return v43;
}
%PrepareFunctionForOptimization(f41);
f41();
%OptimizeFunctionOnNextCall(f41);
f41();
