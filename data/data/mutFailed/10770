const v5 = new Array(6);
const v6 = [58584,15,9007199254740990,2146023485];
const v7 = [46733,-268435456];
Object.defineProperty(v6, 65537, { writable: true, value: v7 });
v5.a = v7;
function f8() {
}
function f9(a10) {
    const v11 = a10.constructor;
    new Uint8ClampedArray(1000);
    try { v11(a10, f8); } catch (e) {}
    class C16 {
    }
}
new WeakSet();
(-64209).constructor;
class C21 {
    static #p(a23) {
        function f24() {
            return a23;
        }
    }
}
const v25 = [4,6,65535,128,25052];
const v26 = [-2147483647];
const v27 = [-1916686572,-1024,9,4294967297,268435441];
function F28(a30, a31, a32, a33) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.a = a33;
    } catch(e34) {
    }
    try {
        this.f = a30;
    } catch(e35) {
    }
    try {
        this.e = a33;
    } catch(e36) {
    }
    function f37() {
    }
    %VerifyType(f37);
    ReferenceError(-64209, -9n);
}
new F28(v5, -9n, v5, -9n);
new F28(v27, -813506151n, v27, -4294967296n);
new F28(v25, -4294967296n, v26, -9n);
function f43() {
    new Uint8ClampedArray();
    function f46() {
        return f46;
    }
    return f43;
}
v26.constructor;
new Int16Array([255,-4294967295,2147483648,2390,8]);
function F51() {
    if (!new.target) { throw 'must be called with new'; }
    const v53 = this?.constructor;
    try { new v53(); } catch (e) {}
}
new F51();
function f56() {
    f56 == f56;
    return 6;
}
%PrepareFunctionForOptimization(v25);
for (let v58 = 0; v58 < 10; v58++) {
    const v59 = [1929306256,-35796];
    try { v59["36049"](); } catch (e) {}
}
f56();
%OptimizeFunctionOnNextCall(f56);
f56();
const v66 = new v25(9);
v66.lastIndexOf(Math.cbrt(7));
