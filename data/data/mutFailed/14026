function f0() {
    new Uint8ClampedArray(127);
    const o5 = {
        "execution": f0,
    };
}
const v8 = new BigInt64Array();
for (const v9 in v8) {
}
for (const v11 in "5amlK") {
    ("5amlK")[v11];
}
function f14(a15) {
    const o16 = {
        ...a15,
        9: 255,
        5: 65536,
        536870889: a15,
        6: a15,
        [a15]: a15,
    };
    return o16;
}
const v19 = Symbol.for(Symbol);
Math.atan2(-988.8649474800335, 10000);
("wOM")[2];
function f27() {
    let v29 = !257;
    const v30 = -v29;
    const v31 = v29--;
    return -536870912;
    function f33() {
        return f33;
    }
    v30 | v31;
    return "-268435456";
}
function F35(a37) {
    if (!new.target) { throw 'must be called with new'; }
    const v38 = this?.constructor;
    try { new v38("wOM"); } catch (e) {}
    try {
        this.h = a37;
    } catch(e40) {
    }
}
try { new F35(255); } catch (e) {}
new F35("-268435456");
new v19("-268435456");
new F35("g");
const v47 = new Array(64);
const v49 = new Float32Array(Float32Array, Float32Array, Float32Array);
function f50() {
    v49.c = Float32Array;
    for (let v51 = 0; v51 < 5; v51++) {
        v51 >>> v51;
        function F53(a55, a56) {
            if (!new.target) { throw 'must be called with new'; }
            const v57 = this.constructor;
            v57.name = v57;
            const v59 = new Int16Array();
            const v60 = v59.lastIndexOf(v59, a56);
            const v61 = v60 ^ v60;
            try { new v57(v61); } catch (e) {}
        }
        const o65 = {
            "execution": "g",
            5: v51,
            "execution": "wOM",
            "type": "wOM",
            "arguments": v47,
        };
        o65[Uint32Array] -= -2147483649;
        return f0;
        const o67 = {
            "maxByteLength": 1814769353,
        };
        class C68 {
        }
        new BigUint64Array(v51, v51, v51);
    }
    return f50;
}
%PrepareFunctionForOptimization(f50);
f50();
%OptimizeFunctionOnNextCall(f50);
const v72 = f50();
v72.caller = v72;
