let v1 = -1.0;
class C3 {
    static a;
    #h = "R5ag";
    static b;
    d;
    g;
    h = "n";
    static #g;
    valueOf(a5) {
        const t10 = "R5ag";
        t10[7] = this;
        let v6;
        try { v6 = new a5(a5, "n", a5, this, this); } catch (e) {}
        a5 >>> v6;
        return v6;
    }
    static 851 = v1;
    static {
        class C9 {
            10;
        }
        new C9();
        new C9();
        new C9();
        let v13;
        try { v13 = new v1(this, this, ...v1, ..."R5ag"); } catch (e) {}
        v13[1] = this;
    }
    e = "R5ag";
}
const v14 = new C3();
const v15 = new C3();
const v16 = new C3();
function f17() {
    return C3;
}
function F18(a20, a21, a22) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.f = a20;
    } catch(e23) {
    }
}
new F18(v15, v16, v15);
const v25 = new F18(v16, v14, v15);
new F18(v14, v15, v16);
class C27 extends f17 {
    o(a29, a30, a31) {
        try {
            super.sinh(a29, v16, this);
        } catch(e33) {
        }
        try {
            this.fuck(-38347n, -38347n, v14, 5.1787980311987845);
        } catch(e37) {
        }
        return a29;
    }
    #f = v1;
}
new C27();
const v39 = new C27();
new C27();
function F41(a43, a44, a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    let v47;
    try { v47 = v39.o(v1, a43, a44, a43, v25); } catch (e) {}
    v47 = F18;
    const v50 = --v1;
    Math.sin(256);
    ~(v50 ** v25);
    const v54 = this.constructor;
    try { new v54(); } catch (e) {}
    typeof Float32Array;
}
const v58 = new F41();
new F41(F41, v58, F41, v58);
