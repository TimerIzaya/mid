const v2 = new Uint8ClampedArray(5);
const v5 = new Uint8Array(2846);
const v8 = new Int8Array(10);
const v9 = v8[7];
class C10 {
    b;
    [v5] = Int8Array;
    m(a12, a13, a14) {
        new Uint8Array(a14, 10, 10);
        super[a14] = Uint8ClampedArray;
        a14 &= 5;
        try { a14(); } catch (e) {}
        return a13;
    }
    static #p(a18, a19, a20) {
        this[10] = Uint8Array;
        const v22 = Symbol.iterator;
        const o31 = {
            [v22]() {
                let v24 = 10;
                const o30 = {
                    next() {
                        v24--;
                        const v28 = v24 == v9;
                        const o29 = {
                            "done": v28,
                            "value": v24,
                        };
                        return o29;
                    },
                };
                return o30;
            },
        };
        return this;
    }
}
const v32 = new C10();
const v33 = new C10();
const v34 = new C10();
function F35(a37, a38, a39, a40) {
    if (!new.target) { throw 'must be called with new'; }
    try { this.propertyIsEnumerable(a38); } catch (e) {}
    a38.e = a38;
    a40.c = a40;
    try {
        this.g = a38;
    } catch(e42) {
    }
}
const v43 = new F35(v2, v32, F35, v34);
const v44 = v43?.__defineGetter__;
try { new v44(10, v2); } catch (e) {}
new F35(10, v34, v34, v33);
const v47 = new F35(v34, v32, 10, v34);
v47.g;
try { new Uint32Array(F35, 10, Uint32Array); } catch (e) {}
const v51 = new Uint32Array();
function f52(a53, a54, a55, a56) {
    -a53;
    try { a54(a55, a54, a53); } catch (e) {}
    for (let i62 = 10 != 10, i63 = 10;
        (() => {
            const v64 = i62 < i63;
            v51[v64];
            return v64;
        })();
        i63--) {
        i62 / i62;
    }
    return f52;
}
for (let v72 = 0; v72 < 5; v72++) {
    f52(v72, Uint32Array, f52, v72);
}
%OptimizeFunctionOnNextCall(f52);
v33();
