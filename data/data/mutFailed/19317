new Map();
class C2 {
    toString(a4) {
        delete this[Map];
        const v7 = Symbol.iterator;
        const o16 = {
            [v7]() {
                let v9 = 10;
                const o15 = {
                    next() {
                        v9--;
                        const v13 = v9 == 0;
                        const o14 = {
                            "done": v13,
                            "value": v9,
                        };
                        return this;
                    },
                };
                return o15;
            },
        };
        return o16;
    }
}
const v17 = new C2();
const v18 = new C2();
const v19 = new C2();
function F21(a23, a24, a25, a26) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.f = a24;
    } catch(e27) {
    }
    try {
        this.e = a23;
    } catch(e28) {
    }
    try {
        this.c = a26;
    } catch(e29) {
    }
}
const v30 = new F21(v19, v17, v18, v17);
const v31 = new F21(C2, v17, v30, v18);
const v32 = new F21(v31, v17, v31, v19);
class C33 {
    constructor(a35, a36, a37, a38) {
        class C40 extends v19.constructor {
            static d = v30;
            #g;
        }
        new C40();
    }
    [F21];
    [v17];
    static [v17] = C2;
    a = v31;
    1000 = v32;
}
const v42 = new C33(v32, v19, v19, v17);
new C33(v17, v42, C33, v19);
new C33(v30, v31, v19, v18);
const v47 = new BigUint64Array(3927);
function f48(a49, a50, a51) {
    try { a49.apply(a50, v47); } catch (e) {}
    f48 ** a50;
    return v19;
}
f48(f48);
