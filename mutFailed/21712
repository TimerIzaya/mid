const v0 = [-256,10,-16193,-2147483647];
const v1 = [-49897,-9007199254740990,50852,65537,16,536870887,9007199254740990,16];
const v2 = [7,44743,7,-1303611349];
function f3(a4) {
    v1.g = a4;
    const o9 = {
        1466829151: a4,
        p(a6) {
            try {
                super.valueOf(this, this);
            } catch(e8) {
            }
            return v1;
        },
        [v0]: v2,
        __proto__: v1,
        [a4]: a4,
    };
    return o9;
}
let v10 = 0;
let v12 = -(v10++);
const v14 = ([1000000.0,0.218433446981681,-5.0,-919787.2036172998,872389.6270716691]).pop;
const v15 = f3(v1);
const v16 = f3(v2);
const v17 = v16[1466829151];
class C19 extends Map {
}
const v20 = new C19();
v20[v17] = Symbol.toStringTag;
f3(v1);
function F24(a26, a27) {
    if (!new.target) { throw 'must be called with new'; }
    const v28 = this?.constructor;
    try { new v28(v16, F24); } catch (e) {}
    try {
        this.b = a26;
    } catch(e30) {
    }
}
const v31 = new v1(v15, f3);
new F24(v15, v31);
new F24(v15, v15);
class C34 {
}
const v35 = new C34();
v35?.constructor;
try { new v2(); } catch (e) {}
-4294967297n / -4294967297n;
const v40 = -4294967297n / -4294967297n;
v12--;
[601759695];
for (let v43 = 0; v43 < 5; v43++) {
    function f44() {
        "Vre" == "Vre";
        "Vre" == C34;
        -4294967295 << -4294967295;
        const o59 = {
            [-4294967297n](a51, a52, a53, a54) {
            },
            ...v14,
            ...v35,
            4: v40,
            toString(a56, a57, a58) {
                return v43;
            },
            5: -4294967295,
        };
        return f44;
    }
    f44();
    %OptimizeFunctionOnNextCall(f44);
}
