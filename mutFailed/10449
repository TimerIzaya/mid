function f0() {
}
const v1 = [NaN];
const v2 = [-8.264111388346185,2.220446049250313e-16,-2.2250738585072014e-308,-565243.2097518438];
const v3 = [-5.0,-1.6106574112962691e+308,-3.0,0.1585156431326491,-881.7726160004977,2.0,-0.0,0.291145358886877];
function F4(a6, a7) {
    if (!new.target) { throw 'must be called with new'; }
    const v8 = this?.constructor;
    try { new v8(this, v2); } catch (e) {}
    try { this.constructor(this, f0); } catch (e) {}
    try { a7.entries(); } catch (e) {}
    try {
        this.f = v3;
    } catch(e12) {
    }
}
try { new F4(v3, F4); } catch (e) {}
const v14 = new F4(v3, v2);
const v15 = new F4(v2, v2);
const v16 = v15.f;
const v17 = new F4(v2, v1);
v17.c = v17;
1000000000.0 | 1000000000.0;
WeakSet.prototype = WeakSet;
const v23 = new v14();
const v24 = [v23,v14,v14,v3,v3,v3,v23,v16];
try { v24.filter(-5.0); } catch (e) {}
[F4];
const v27 = [f0,f0,1000000000.0];
v27[1] = v27;
const v30 = Int8Array?.apply;
try { new v30(v1, v23); } catch (e) {}
const v32 = new Int8Array(5);
try { v32.slice(Int8Array, v30); } catch (e) {}
v32.BYTES_PER_ELEMENT = v32;
127 % 127;
try { new BigUint64Array(BigUint64Array, Int8Array, v17); } catch (e) {}
const v40 = new BigUint64Array(v16);
let v41 = -2147483648;
v41--;
v41 << v41;
-4294967295 << -4294967295;
1000 >>> 1000;
v32[v40];
try { Math.log(v15); } catch (e) {}
let v58 = 324308659;
v58--;
Uint32Array.isNaN(Math.sin());
v58 + v58;
