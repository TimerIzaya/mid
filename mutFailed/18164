const v0 = [];
const v3 = new Int16Array(1155);
new Float32Array(15);
const v9 = new Uint32Array(1);
class C10 {
    static set a(a12) {
        try {
            v9.includes(Float32Array);
        } catch(e14) {
        }
        h = 15;
        new Int16Array(this, a12, 15);
    }
    get d() {
        const v17 = this << this;
        try {
            v0.h = v17;
            class C19 {
                static {
                    new this(this, this, this, this, 852);
                }
                constructor(a23) {
                    const v24 = this.constructor;
                    try { new v24(a23, 852, v24, a23); } catch (e) {}
                    const v28 = ~(852 && 852);
                    Math.sinh(Math);
                    +v28;
                }
            }
            new C19(C19);
        } catch(e32) {
        }
        return v3;
    }
    constructor(a34, a35, a36) {
        super();
        const o38 = {
        };
        gc(o38);
    }
}
new C10();
new C10();
new C10();
Promise.race();
function F48(a50, a51) {
    if (!new.target) { throw 'must be called with new'; }
    const v52 = this.constructor;
    try { new v52(); } catch (e) {}
    try { this.constructor(); } catch (e) {}
}
for (let v56 = 0; v56 < 5; v56++) {
    function f57() {
        const v59 = ("c").toLowerCase();
        const v60 = 1864489360 << v59;
        const v61 = /8[\cA]v/uisy;
        const v62 = [3480,1024,-4294967297,-1024,512,65536,29198,-9223372036854775807,-2147483647];
        try {
            v62.length = v61;
        } catch(e63) {
        }
        v60 & v60;
        return v59;
    }
    new BigUint64Array(4);
    class C68 {
    }
    f57();
    %OptimizeFunctionOnNextCall(f57);
}
new F48();
