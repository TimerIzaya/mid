const v2 = new Uint8Array(0);
function f3() {
    function f4(a5) {
        let v6;
        try { v6 = new a5(v2, a5, a5, a5, 0); } catch (e) {}
        try { v6(); } catch (e) {}
        return a5;
    }
    return f4;
}
Object.defineProperty(v2, "constructor", { writable: true, configurable: true, enumerable: true, get: f3 });
127 - 127;
function F11(a13, a14) {
    if (!new.target) { throw 'must be called with new'; }
    const v15 = this.constructor;
    try { new v15(); } catch (e) {}
    this.a = Uint16Array;
}
const v18 = new Uint16Array(127);
v18[Symbol.hasInstance] = f3;
let v21;
try { v21 = v2.slice(0, 0); } catch (e) {}
v21.toString = Symbol;
try { v21.entries(); } catch (e) {}
function f23() {
    return F11;
}
f23.name;
const v27 = v18[Symbol.hasInstance];
function f28(a29, a30, a31) {
    const o36 = {
        get a() {
            const o34 = {
            };
            gc();
        },
    };
    return o36;
}
f28[Symbol.toPrimitive] = f3;
f28();
1024 + 1024;
Uint8ClampedArray[Symbol.iterator] = f28;
try { new Uint8ClampedArray(Uint8ClampedArray, v27, f28); } catch (e) {}
new Uint8ClampedArray(1024);
9 << 9;
new BigInt64Array(9);
let v51 = 129;
v51++;
new Int8Array(v51);
new Uint16Array(183);
const v58 = v21 < f28;
if (v58) {
    let v59 = v58 ^ v58;
    v59--;
} else {
}
function F64(a66, a67) {
    if (!new.target) { throw 'must be called with new'; }
    Object.defineProperty(a67, "a", { configurable: true, value: a66 });
    a67.a = a67;
}
F64.a = 0;
const v68 = new F64(F64, F64);
const v69 = v68?.constructor;
try { new v69(BigInt64Array, Uint16Array); } catch (e) {}
const v72 = ~v68;
v72 - v72;
Math.asinh(v72);
3 + 3;
const v78 = new Int32Array(3);
v78[1];
v78.indexOf();
Array(5);
