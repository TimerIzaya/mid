function f0() {
}
class C1 {
    constructor() {
        const o5 = {
            "maxByteLength": 255,
        };
        const v7 = new ArrayBuffer(255, o5);
        function f8(a9, a10) {
            const o11 = {
                ...a9,
            };
            return f8;
        }
        o5 < o5;
        try { RangeError(RangeError); } catch (e) {}
        class C16 {
            p(a18, a19, a20, a21) {
            }
        }
        const t20 = ([C16])[Symbol.iterator].constructor;
        t20(C16);
        new Uint32Array(v7);
    }
    static #e = f0;
}
const v29 = new C1();
const v30 = new C1();
const v31 = new C1();
function F32(a34, a35) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.d = v31;
    } catch(e36) {
    }
    try {
        this.h = v29;
    } catch(e37) {
    }
}
const v38 = new F32(C1, v30);
const v39 = new F32(v38, C1);
new F32(v38, v31);
function f41() {
    return f0;
}
class C42 {
    static {
        if (v39) {
            let v46 = -128;
            v46--;
            function f48(a49, a50, a51, a52) {
                return arguments;
            }
            Math.log1p(!(-2 ^ (-2 % this)));
        } else {
            this[2] = this;
        }
    }
}
new C42();
new C42();
new C42();
class C61 {
    static toString(a63, a64) {
        const v66 = super[a64];
        try {
            delete this[v66];
            this[C61];
        } catch(e69) {
        }
    }
}
const v70 = new C61();
const v72 = new Uint8ClampedArray(C61, C61, v70);
function f73() {
    function f74(a75, a76) {
        const v77 = v70.constructor;
        v77 + v77;
        return f74;
    }
    f74(Uint8ClampedArray, Uint8ClampedArray);
    return f74;
}
Object.defineProperty(v72, "valueOf", { get: f73 });
v72[5] = v72;
