const t0 = [905648095,-2147483647,-17682,10];
t0.g = -4;
const v7 = new Uint32Array(2091);
for (const v9 in v7[0]) {
}
[-9223372036854775807,16,-9548,-39085];
[10];
class C18 extends Date {
}
const v19 = new C18();
const v20 = v19.toGMTString();
const v21 = [155533.8602852358,2.0];
function F23() {
    if (!new.target) { throw 'must be called with new'; }
    Array(19793);
    v21[658291203] = null;
    v20[1073741824];
}
([-4294967297n]).toLocaleString();
const v35 = ("boolean").split("toString");
const v36 = [-6.672391061426152e+307];
function f38() {
    let v39 = 8n;
    const v42 = [v39++] > v39;
    ~v36["pop"]();
    let v46 = 0;
    const o49 = {
        "maxByteLength": 1814769353,
    };
    const v51 = new SharedArrayBuffer(12, 12);
    try { v51.grow(-10); } catch (e) {}
    Uint32Array.e = Uint32Array;
    while ((v46 < 10) || v42) {
        for (let v57 = 0; v57 < 5; v57++) {
            const v58 = [-1.7976931348623157e+308,1.567547754457685];
            new Uint32Array(v58, v58, Uint32Array);
            function f61(a62, a63) {
                const o66 = {
                    "h": v20,
                    [a63]: v20,
                    set h(a65) {
                    },
                };
                return f61;
            }
            %PrepareFunctionForOptimization(f61);
            o49.constructor;
            const v71 = new Int16Array();
            const v74 = new BigUint64Array(2, 256);
            v71["fill"](v74, 256, 2);
            "pop" + v57;
        }
        v46++;
    }
    class C79 {
    }
    new C79();
    class C83 extends Array {
        16 = 4;
        268435440;
    }
    return v42;
}
%PrepareFunctionForOptimization(f38);
f38();
%OptimizeFunctionOnNextCall(f38);
v35.sinh(0);
new Uint8ClampedArray(([127,506635944,-9223372036854775808,5,-536870912,-12000821,2147483649]).toSpliced(-1148418937, -1148418937));
f38();
