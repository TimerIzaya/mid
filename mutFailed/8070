function f1(a2) {
    a2 = Set;
    Set[4];
    return a2;
}
Set.toString = f1;
let v4 = new Set();
function f5(a6) {
    const o12 = {
        [Set](a8, a9) {
            v4 <<= a6;
            try {
                new Set(this);
            } catch(e11) {
            }
            return this;
        },
        "b": Set,
        __proto__: v4,
    };
    return o12;
}
const v13 = f5(f5);
const v14 = f5(v13);
const v15 = f5(Set);
function f16(a17, a18, a19) {
    const o28 = {
        toString(a21, a22, a23, a24) {
            const v25 = new f5(a24, a23, a22, a21);
            const v26 = this % v25;
            let v27;
            try { v27 = new a21(a24, v26, v26, a17); } catch (e) {}
            a21[7] %= v26;
            v15[v4] = v27;
            return a18;
        },
        ...v15,
        __proto__: a17,
    };
    return o28;
}
f16(v13, v4, v14);
f16(v13, f16(v13, v13, Set), f5);
const v35 = new Int8Array();
for (const v36 in v35) {
}
const v37 = [-8,-9007199254740991,-2,5,-710979536,-16743,-722516666,-14817,1352913669,1];
const v38 = [601759695];
const v39 = [1073741824,1073741823,1376142744,1073741825];
function f41(a42, a43, a44, a45) {
    function f47() {
        const o56 = {
            "e": -4294967295,
            ...v37,
            84: arguments,
            ..."Vre",
            set b(a51) {
            },
            ["Vre"](a53, a54) {
                super[f47];
            },
        };
        return a42;
    }
    class C58 extends Float32Array {
        constructor(a60, a61, a62) {
        }
    }
    f47();
    %OptimizeFunctionOnNextCall(f47);
    let v65;
    try { v65 = v39[a44](..."find", a45, ...v38, ...v39, ...522675525n); } catch (e) {}
    v65 <= a44;
    return arguments;
}
try { f41(964598.6714444079, 964598.6714444079, 964598.6714444079, v38); } catch (e) {}
let v70 = 5;
-9 >>> -9;
const v73 = [-2.220446049250313e-16,-1.2960362069804638,1000000.0];
const v74 = [-1.4967617591971738,2.0,-2.2250738585072014e-308,0.30325345191391684,-1000000000.0,-471.48827446067276,0.4054223816062078,-3.1156994274492186e+307,1000.0];
try { v74.map(1.0); } catch (e) {}
const v77 = Symbol.species;
v73[v77] = 8.580387257773513;
~268435440;
Uint8Array.length;
new Uint8Array(268435440);
v77.description = 964598.6714444079;
v70 = -15;
const v85 = new Int8Array(8);
[v85];
995 | 995;
const v90 = new Uint8ClampedArray(995);
const v92 = new Int8Array(v90);
const v93 = v92.copyWithin;
v93.name = v93;
for (let v94 = 0; v94 < 32; v94++) {
    v73[-2] = -9 << v94;
    const v96 = v74[v77];
    try {
        v96.__proto__ = v96;
    } catch(e97) {
        e97.g = e97;
    }
    const v99 = new Uint8ClampedArray();
    v99.byteOffset;
    Math.sin(/c(?:ab)|cde/vdmy.exec());
    const v106 = "object" + v94;
    const v107 = v106?.trim;
    try { new v107(); } catch (e) {}
    v74[v106] = v94;
}
const v109 = [1000000.0,69.5407062634481,-1e-15,NaN];
function F110(a112, a113, a114, a115) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = a112;
}
const v116 = [-1000000.0,0.1600379490765781,-1.6243694690977962e+307,817210.0157459241,1.0,5.0,0.9202958446582343,-1.7976931348623157e+308,-382.2774365702321,-5.737866676165018e+307];
class C118 {
    static #e;
    m(a120, a121, a122, a123) {
        v116.#e;
        a121.#e = -1;
    }
}
let v126 = 0;
v126 & v126;
do {
    break;
    v109[Symbol.asyncIterator] = v73;
    v126++;
} while (v126 < 9)
Uint8ClampedArray.name;
const v136 = new Uint8ClampedArray(995);
new Int8Array(v136);
const v141 = new Float64Array(Float64Array, Float64Array);
class C142 extends Int16Array {
}
const v143 = new C142();
const o144 = {
    __proto__: v143,
};
try { v141.every(o144); } catch (e) {}
