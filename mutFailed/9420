const v0 = [-8.898326096793244e+307,-1.7546648676067544,5.0,3.858432955280852e+306,1.0,2.4921047079429085e+307,-1000.0,-967361.620743413,-1e-15,257.9289481300102];
const v1 = [-57057595,-708341426,-27428,-9007199254740991];
const v2 = v1[2];
for (let v3 = 0; v3 < 5; v3++) {
    function f4() {
        const v6 = new Uint8ClampedArray();
        v6.valueOf = f4;
        v6[2327] = v6;
        return Uint8ClampedArray;
    }
    f4();
    %OptimizeFunctionOnNextCall(f4);
}
try {
    v1.c = v1;
} catch(e8) {
}
v1 * v2;
const v10 = [-1.897912128292746e+307,651166.7160719032,2.2250738585072014e-308,-2.220446049250313e-16,5.0,2.0,1.0,-1.0,4.985139881484849e+307,2.220446049250313e-16];
[3.7057853621434838,-2.220446049250313e-16,-2.220446049250313e-16];
function F15(a17, a18) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = this;
    "m" > a18 ? "m" : a18;
    class C22 {
    }
    try {
        this.d = v10;
    } catch(e23) {
    }
    try {
        this.f = "N3";
    } catch(e24) {
    }
    try {
        this.e = a17;
    } catch(e25) {
    }
}
const v28 = Math.clz32(v0);
v0 | F15;
const v30 = F15 + -1830641306;
Math.abs(v30);
v30 + F15;
new F15("boolean", "boolean");
new F15(F15, "boolean");
new F15(v0, "m");
new Uint8Array(2);
let v39 = 0;
while (v39 < 6) {
    try {
        const t51 = "N3";
        t51.d = v28;
    } catch(e42) {
    }
    v39++;
}
new Uint32Array(16);
new Uint32Array(598);
Symbol.hasInstance.toString();
