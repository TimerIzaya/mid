const v2 = new Int8Array(1024);
const v5 = new Uint8ClampedArray(4);
Uint32Array.name;
const v9 = new Uint32Array(8);
v9[1] = v9;
function f13() {
    return Int8Array;
}
function f14(a15, a16, a17, a18) {
    const o48 = {
        "g": f13,
        "b": v9,
        ...v5,
        "h": a16,
        __proto__: v2,
        "f": f13,
        138: v9,
        ...v9,
        ...v5,
        [v2](a20, a21, a22) {
            try {
                v2.c = Uint8ClampedArray;
            } catch(e23) {
                v5[this];
                delete a15?.[1073741824];
                f13();
                %PrepareFunctionForOptimization(f13);
                f13();
                f13();
                %OptimizeFunctionOnNextCall(f13);
                f13();
            }
            function F30(a32, a33, a34, a35) {
                if (!new.target) { throw 'must be called with new'; }
                try {
                    this.c = a35;
                } catch(e36) {
                }
            }
            new F30(4, a15, 4, a20);
            new F30(a20, a20, a20, a21);
            const v42 = !-1;
            const v43 = v42 && v42;
            !(a20 & v43) >>> v43;
            new F30(4, a22, a18, 8);
            return a17;
        },
    };
    return o48;
}
f14(2, 2, 1024, 1024);
f14(4, 4, 8, 2);
const v51 = f14(4, 1024, 2, 1024);
function f52(a53, a54, a55, a56) {
    a53 >> a53;
    function f58() {
        let v60 = Math.expm1(a54);
        v60--;
        const v62 = v60.tanh(Math);
        const o63 = {
            [v62]: v60,
        };
        o63.NaN = o63;
        return o63;
    }
    f58.arguments;
    const v66 = f58()?.__defineSetter__;
    try { new v66(a54, 4); } catch (e) {}
    eval(a54);
    %OptimizeFunctionOnNextCall(f58);
    return f52;
}
let v70 = v5[2147483649];
v70 = v9;
try {
    v51.g = 8;
} catch(e71) {
}
for (let v72 = 0; v72 < 5; v72++) {
    v72 >> v72;
    f52(v72, v72);
}
