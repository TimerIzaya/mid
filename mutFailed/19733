Array();
[Reflect];
const v11 = [601759695];
const v12 = [1073741824,1073741823,1376142744,1073741825];
function f13(a14, a15, a16, a17) {
    try { v12["find"](..."find", a17, ...v11, ...v12); } catch (e) {}
    const v22 = Symbol.isConcatSpreadable;
    const v23 = v22.description;
    const v24 = Array(a16);
    try { v24.groupToMap(v22, v23, f13, v24, v22); } catch (e) {}
    return v11;
}
f13();
let v27 = 9;
v27--;
function F29() {
    if (!new.target) { throw 'must be called with new'; }
    Array(4087).includes(4087);
}
new F29();
const v37 = [-1,-1,"stack",-1625600800,-1];
const v41 = new Int8Array(8);
Reflect.construct(Uint16Array, [v41]);
function f45() {
    return f45;
}
const v46 = f45();
v46.constructor = f45;
const v47 = v46.constructor;
try { v37.group(-1); } catch (e) {}
const v49 = [];
const o51 = {
    [v49]: v49,
    get h() {
        return this;
    },
};
const v52 = [58544];
v52.toString = f45;
const v53 = v52?.unshift;
try { new v53("-4294967295"); } catch (e) {}
4.0 - 4.0;
class C58 {
    p(a60, a61, a62) {
        -1000000000000.0 >= a60;
        Math.acos();
    }
}
const v66 = ["race",v52,v52,-1,"stack"];
try { v66.with(v66, v66); } catch (e) {}
new Int16Array(517);
new Float32Array(129);
new BigUint64Array(255);
Number[Symbol.toPrimitive] = f45;
function f80(a81, a82) {
    function f83() {
        return f45;
    }
    Object.defineProperty(a82, "toString", { writable: true, enumerable: true, get: f83 });
    Number(a81);
    parseFloat(parseFloat);
    const o88 = {
    };
    gc(o88);
    return a82;
}
f80.d = v47;
f80.d = f80;
%PrepareFunctionForOptimization(f80);
f80(Number, Number);
%OptimizeFunctionOnNextCall(f80);
f80();
