class C3 {
    constructor(a5) {
        const t2 = 9007199254740992;
        t2[3] = "symbol";
        let v6 = 10;
        for (; v6--;) {
            const v8 = super.c;
            v8[v8] = 9007199254740992;
        }
    }
}
const v9 = new C3(9007199254740992);
const v10 = new C3(v9);
new C3(-1.8861265273658787e+307);
function F15(a17, a18, a19, a20) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        class C21 extends F15 {
            #e;
        }
        new C21();
        new C21();
        new C21();
        this.e = a19;
    } catch(e25) {
    }
}
const v26 = new F15(C3, F15, -1.8861265273658787e+307, -1.8861265273658787e+307);
const v27 = new F15(v9, 2917, "symbol", v10);
new F15(v9, v27, 1896321828, 1230620146);
let v29 = Map;
v29--;
const v31 = [-4.0,-1e-15];
function f32() {
    function f34(a35) {
        Reflect.construct(a35, [Reflect,1230620146,Reflect,Reflect], C3);
    }
    this.onmessage = f34;
}
const v44 = [];
const o45 = {
    "arguments": v44,
    "type": "function",
};
new Worker(f32, o45);
v31[2] = v31;
[-7.264687027014153e+307];
function F48(a50, a51, a52, a53) {
    if (!new.target) { throw 'must be called with new'; }
    for (let v54 = 0; v54 < 25; v54++) {
        const v57 = new BigUint64Array(3375);
        let [v58,,v59,...v60] = v57;
    }
    try { a50.unshift(a51); } catch (e) {}
    try { a50.toSpliced(); } catch (e) {}
}
new F48(v31);
function f64(a65) {
}
class C66 extends f64 {
    static 1727269869;
    #e;
    static d = C3;
    static e;
    static #f = v26;
}
