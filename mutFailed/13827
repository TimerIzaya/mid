let v2 = -12;
const v5 = new Date(v2 % v2);
class C7 {
    #b = v2;
    g = 1.1408591040999836e+308;
    static {
        let v9;
        try { v9 = new this(); } catch (e) {}
        v9.e = v9;
        this.e = this;
        try { Math.tan(Math); } catch (e) {}
        let v13 = 44149;
        -v13;
        v13--;
        const v16 = v2++;
        const v17 = v16 & v16;
        let v18 = -v16;
        v18++;
        let v20 = ~v2;
        v20--;
        Math.log10(v13);
        const v23 = v13 + v2;
        v23 + v17;
        for (const v25 in v5) {
            Date.prototype += v20;
        }
        Object.defineProperty(Math, "PI", { enumerable: true, get: Date, set: Date });
        Math[this];
        v23 >> v23;
        const v28 = Math.fround(v16);
        v28 >> v28;
    }
}
try { new C7(); } catch (e) {}
function F36() {
    if (!new.target) { throw 'must be called with new'; }
    let v37 = this;
    function f39(a40) {
        return F36;
    }
    this.onmessage = f39;
    v37 = this;
    Date[6] = "function";
    f39 >= "function" ? f39 : "function";
    const o48 = {
        "type": "function",
    };
    new Worker(F36, o48);
}
new F36();
function f56(a57, a58) {
    const o59 = {
        "d": a58,
        "c": -5,
    };
    return o59;
}
class C62 {
}
function F64(a66, a67, a68) {
    if (!new.target) { throw 'must be called with new'; }
    const v69 = this.constructor;
    try { new v69(this, a68, -14); } catch (e) {}
    a68.valueOf(a66, a68);
}
const v75 = [];
const v76 = [v75,v75,v75,v75];
const v77 = [v76,v76,v76];
function f78() {
    return v77;
}
f78();
("toString").match();
