class C3 {
    static #d;
    toString(a5) {
        let v6;
        try { v6 = new a5(a5, a5, this, 9007199254740990); } catch (e) {}
        try {
            v6.toString = a5;
        } catch(e7) {
        }
        return this;
    }
    static a;
    static [12] = 12;
    static #b;
}
new C3();
const v9 = new C3();
const v10 = new C3();
class C11 extends C3 {
    constructor(a13, a14, a15, a16) {
        super();
        if (v10 < this) {
            delete this[this];
        } else {
            try { a14(a14); } catch (e) {}
        }
    }
    #p(a21, a22) {
        a21 * C11;
        return a21;
    }
    g = v10;
    #c = 9007199254740990;
    static [9007199254740990];
    b = 12;
}
new C11(-1497908213, -1497908213, -1497908213, 9007199254740990);
new C11(9007199254740990, v9, 12, -1497908213);
new C11(9007199254740990, -1497908213, 9007199254740990, 9007199254740990);
class C33 {
    toString(a35, a36) {
        const v37 = `7${this}dm${"unicode"}m`;
        function F38(a40, a41, a42) {
            if (!new.target) { throw 'must be called with new'; }
        }
        F38(F38(), "unicode", v37);
    }
}
