const v0 = [NaN,1.438471533441394e+308,668.6609885462037,1.2764480462836523e+308,-292093.1007833078,-1e-15,7.140778975581895,-0.4876735834361412,-52.702501267940306];
const v1 = [5.0,0.06258836922297717];
const v2 = [-0.0,1000000000.0,-8.5885931999301e+307,-3.4412528761880594,-1000000000000.0,-19209.454339536955,-965.644234823041,-Infinity,-9.72273051287056,0.5855174701509448];
const v4 = [[v2,v2,v0,v0],v1,v2];
[v4,v0,v2];
try { new BigUint64Array(v1, v4, BigUint64Array); } catch (e) {}
new v0(16);
52 - 52;
try { new BigUint64Array(52, 52, v1); } catch (e) {}
new BigUint64Array(52);
new BigInt64Array(4);
0 < 1;
const v24 = new Uint16Array(2);
const v25 = new Uint16Array(v24);
for (const v26 in v25) {
}
const v28 = new Int32Array(1024);
Math.sin(52);
function f32(a33, a34, a35) {
    return f32;
}
class C36 extends f32 {
}
let v37 = this;
try { (4).isExtensible(BigInt64Array); } catch (e) {}
const v40 = [v28];
v40.g = v40;
new BigUint64Array();
function F43(a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    a46--;
}
const v48 = Reflect.construct(Int32Array, v40);
v48[487] = v48;
const o49 = {
};
gc.arguments = gc;
gc();
v37 >>>= Reflect;
