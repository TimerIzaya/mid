const v4 = new Int8Array();
for (const v5 in v4) {
}
const v6 = [-8,-9007199254740991,-2,5,-710979536,-16743,-722516666,-14817,1352913669,1];
const v7 = [601759695];
const v8 = [1073741824,1073741823,1376142744,1073741825];
function f10(a11, a12, a13, a14) {
    function f16() {
        const o25 = {
            "e": -4294967295,
            ...v6,
            84: arguments,
            ..."Vre",
            set b(a20) {
            },
            ["Vre"](a22, a23) {
                super[f16];
            },
        };
        return a11;
    }
    class C27 extends Float32Array {
        constructor(a29, a30, a31) {
        }
    }
    f16();
    %OptimizeFunctionOnNextCall(f16);
    let v34;
    try { v34 = v8[a13](..."find", a14, ...v7, ...v8, ...522675525n); } catch (e) {}
    v34 <= a13;
    return arguments;
}
try { f10(964598.6714444079, 964598.6714444079, 964598.6714444079, v7); } catch (e) {}
let v39 = 5;
-9 >>> -9;
const v42 = [-2.220446049250313e-16,-1.2960362069804638,1000000.0];
const v43 = [-1.4967617591971738,2.0,-2.2250738585072014e-308,0.30325345191391684,-1000000000.0,-471.48827446067276,0.4054223816062078,-3.1156994274492186e+307,1000.0];
try { v43.map(1.0); } catch (e) {}
const v46 = Symbol.species;
v42[v46] = 8.580387257773513;
~268435440;
Uint8Array.length;
new Uint8Array(268435440);
v46.description = 964598.6714444079;
v39 = -15;
const v54 = new Int8Array(8);
const v55 = [v54];
995 | 995;
const v59 = new Uint8ClampedArray(995);
const v61 = new Int8Array(v59);
const v62 = v61.copyWithin;
v62.name = v62;
for (let v63 = 0; v63 < 32; v63++) {
    v42[-2] = -9 << v63;
    const v65 = v43[v46];
    try {
        v65.__proto__ = v65;
    } catch(e66) {
        e66.g = e66;
    }
    const v68 = new Uint8ClampedArray();
    v68.byteOffset;
    Math.sin(/c(?:ab)|cde/vdmy.exec());
    const v75 = "object" + v63;
    const v76 = v75?.trim;
    try { new v76(); } catch (e) {}
    v43[v75] = v63;
}
const v78 = [1000000.0,69.5407062634481,-1e-15,NaN];
function F79(a81, a82, a83, a84) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = a81;
}
const v85 = [-1000000.0,0.1600379490765781,-1.6243694690977962e+307,817210.0157459241,1.0,5.0,0.9202958446582343,-1.7976931348623157e+308,-382.2774365702321,-5.737866676165018e+307];
class C87 {
    static #e;
    m(a89, a90, a91, a92) {
        v85.#e;
        a90.#e = -1;
    }
}
let v95 = 0;
v95 & v95;
do {
    break;
    v78[Symbol.asyncIterator] = v42;
    v95++;
} while (v95 < 9)
Uint8ClampedArray.name;
const v105 = new Uint8ClampedArray(995);
const v107 = new Int8Array(v105);
const v109 = new Int16Array(3);
Int8Array.e = Int8Array;
const v112 = new Int8Array(86);
const v115 = new Uint8ClampedArray(8);
function f116(a117, a118, a119, a120) {
    a117 * a117;
    a119 >> a119;
    const o126 = {
        "d": v112,
        "c": v109,
        __proto__: a117,
        ...v109,
        set b(a124) {
            try {
                v112.byteOffset = a120;
            } catch(e125) {
            }
        },
    };
    return o126;
}
f116.name;
f116(3, 86, 8, 8);
const v129 = f116(Uint8ClampedArray, 3, 8, 3);
v129[2] = v129;
f116(v112, 3, 86, 3);
function f131(a132, a133, a134, a135) {
    delete v115?.byteOffset;
    try { v55.toLocaleString(); } catch (e) {}
    try { v107.toReversed(); } catch (e) {}
    Object.defineProperty(Symbol, 8, { writable: true, get: Symbol });
    a134[5] = v8;
    const v141 = new Date(a132);
    const v143 = new Set();
    const v144 = v143.add(v141);
    let [v145,,...v146] = v143;
    const v147 = v145?.setFullYear;
    try { new v147(v143, v129, f116); } catch (e) {}
    let v149;
    try { v149 = v146.findLast(); } catch (e) {}
    const v150 = v145.setUTCHours(v144, Float64Array, v146);
    v150 % v150;
    try { Number.parseInt(a135, 86); } catch (e) {}
    const o154 = {
        __proto__: v143,
    };
    try { o154.add(v143); } catch (e) {}
    function f156() {
        return v149;
    }
    const v157 = f156();
    class C158 extends f156 {
    }
    const v160 = new Int32Array(v157);
    v160.BYTES_PER_ELEMENT = v160;
    Number.isNaN(v150);
    const v162 = v145.setUTCFullYear(v160, f131, f131, v145);
    v162 - v162;
    return v162;
}
for (let v164 = 0; v164 < 25; v164++) {
    const v165 = [1073741824,1073741823,1376142744,1073741825];
    for (let v166 = 0; v166 < 5; v166++) {
        v166 / v166;
        const v168 = v165.toSorted(f131);
        try { v168.fill(v165); } catch (e) {}
    }
}
