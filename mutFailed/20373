class C3 {
    constructor(a5, a6) {
        const t2 = "symbol";
        t2[-0.0] = a5;
        try { ("symbol").substring(..."symbol", ...-0.0, this, ..."symbol", a6, ..."symbol"); } catch (e) {}
    }
    static #o(a9) {
        this["symbol"] *= a9;
        [Reflect];
        new Uint8ClampedArray(14);
        const v15 = -0.0 != this;
        const v16 = v15 ? -0.0 : this;
        const o18 = {
        };
        try {
            o18.g = "e";
        } catch(e19) {
        }
        const v20 = super[v16];
        try { new v20(v15, v15, v20); } catch (e) {}
        return v15;
    }
    g = "symbol";
    static #d;
}
new C3(-0.0, 276175.6597058831);
const v23 = new C3(C3, -0.0);
new Int8Array(9);
function f27() {
}
new C3("symbol", v23);
const v34 = [1073741824,1073741823,1376142744,1073741825];
function f35() {
    try {
        v34.forEach("symbol");
        let v39 = BigUint64Array * 536870887;
        v39--;
    } catch(e41) {
    }
    return 6;
}
class C43 {
    65535;
    static set d(a45) {
        try {
            delete v23["symbol"];
            const v49 = new Uint8Array();
            v49[8] = Uint16Array;
            function F50(a52, a53) {
                if (!new.target) { throw 'must be called with new'; }
                a53 - a53;
                const v55 = this.constructor;
                v55.name = v55;
                const v57 = new Int16Array(a53);
                const v58 = v57.lastIndexOf(F50, a52);
                v58 ^ v58;
                try { new v55(this, a52); } catch (e) {}
            }
        } catch(e61) {
            this ** e61;
        }
    }
    valueOf(a64, a65, a66) {
        AggregateError.captureStackTrace(AggregateError, 257);
        Math.asin(2.220446049250313e-16);
        return "EqtJP";
    }
}
new C43();
new C43();
new C43();
class C79 {
}
const v80 = new C79();
const v81 = v80.constructor;
function f82(a83, a84, a85, a86) {
    const v89 = new BigInt64Array(4046);
    let v90 = undefined;
    const v91 = v90++;
    v91 >> v91;
    v91 + v91;
    v91 >> v91;
    let o95 = {
    };
    [,...o95] = v89;
    return f82;
}
for (let v96 = 0; v96 < 5; v96++) {
    f82(v96, v96, v96, v96);
}
let v98 = new v81();
const v99 = /[\11]/gm;
function f100() {
    return v98 >>>= f100 != v99;
}
%PrepareFunctionForOptimization(f100);
f100();
%OptimizeFunctionOnNextCall(f100);
f100();
