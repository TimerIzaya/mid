const v3 = [-60683n,-1820128352n];
const v4 = [-60683n,v3,v3,-604894476n,v3];
const v5 = [v4,v3];
let v6;
try { v6 = v5.map(-60683n); } catch (e) {}
class C7 {
    3 = v4;
    f;
    static #e = -1820128352n;
    constructor(a9, a10, a11) {
        this[3] = this;
        a9[1] = a9;
        let v12;
        try { v12 = a10.findLastIndex(a10); } catch (e) {}
        a11[4] = a11;
        -60683n == -604894476n;
        try { a11(v12, v3); } catch (e) {}
        try {
            super.m();
        } catch(e16) {
        }
    }
    [v3] = v4;
    static #g = v4;
    [-60683n] = -60683n;
}
const v17 = new C7(v3, v3, v4);
v17[3] = v17;
const v18 = new C7(v4, v17, v3);
const v19 = new C7(v3, v5, v17);
new Array(6);
function F23(a25, a26) {
    if (!new.target) { throw 'must be called with new'; }
    const v27 = a26?.constructor;
    try { new v27(Array, -604894476n, Array); } catch (e) {}
    try {
        v19.b = C7;
    } catch(e29) {
    }
    try {
        this.f = a25;
    } catch(e30) {
    }
}
F23.arguments = F23;
new F23(-60683n, v6);
new F23(-1820128352n, v17);
new F23(-604894476n, v18);
const v35 = ("entries")?.trimRight;
try { new v35(); } catch (e) {}
v6.toUpperCase();
