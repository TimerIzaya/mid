const v3 = new Float64Array();
function F4(a6, a7) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.d = a6;
    } catch(e8) {
        for (let [v9,v10] of a6) {
        }
    }
    try {
        const v11 = v3[this];
        const v12 = [];
        new Float32Array(7);
        v12[1];
        new F4(v11, -268435456n);
    } catch(e19) {
    }
}
class C21 {
    set g(a23) {
        %VerifyType(this);
        const v26 = new Uint16Array(6);
        v26.lastIndexOf(4);
        class C29 {
            1;
        }
        new C29();
        new C29();
        new C29();
    }
    static a;
    [-65535];
    static 1000;
    #b;
}
try { new C21(); } catch (e) {}
const v34 = new C21();
try { v34.constructor(); } catch (e) {}
const v36 = new C21();
const v37 = v36?.constructor;
try { new v37(); } catch (e) {}
new C21();
const v45 = new Uint32Array(4096);
v45[3815] = v45;
new Int32Array(234);
const v51 = new Int16Array(8);
try { v51.filter(234); } catch (e) {}
~-754089042n;
C21[6];
C21();
function f57() {
    return f57;
}
159 / 159;
[1000000000.0,-1000.0];
function F61(a63, a64) {
    if (!new.target) { throw 'must be called with new'; }
    this.hasOwnProperty();
    const v66 = this.constructor;
    try { new v66(); } catch (e) {}
    Math.E = Math;
    const v72 = Math.round();
    for (let v73 = 0; v73 < 10; v73++) {
        v73 / v73;
        async function f75(a76, a77, a78) {
            a78 >>> a78;
            Number.isNaN(await v72);
            const v84 = [0.8307152163010869,1.0,0.0];
            v84[2] = v84;
            v84.length = v73;
            %VerifyType(v84 instanceof -24894);
            return f75;
        }
        try { f75(-788.7260290236088, -1000000000.0, -1000000000.0); } catch (e) {}
        const v87 = f75(Math, "b", v72);
        try { v87.hasOwnProperty(-788.7260290236088); } catch (e) {}
    }
}
const v89 = new F61();
const v90 = v89?.constructor;
try { new v90(v34, -65535); } catch (e) {}
new F61();
