new Uint32Array(2899);
let v3 = 260;
const v5 = new Int16Array(v3);
new Int32Array(2899);
function F8(a10, a11, a12, a13) {
    if (!new.target) { throw 'must be called with new'; }
    ("entries").toUpperCase();
    ~a11;
    const v17 = this.constructor;
    try { new v17(); } catch (e) {}
}
const v21 = new Float64Array(64);
class C22 extends Uint32Array {
    static m(a24, a25, a26, a27) {
        this[Uint32Array];
        function f29() {
            return 64;
        }
        const v32 = new Uint8Array(9);
        v32.lastIndexOf(2899);
        class C34 {
        }
        Float64Array && this;
        return 64;
    }
    6;
    [-2] = v21;
    static {
        for (const v37 in v5) {
            v5[2899] += 2899;
            const v38 = [128,215394418];
            try { v38.entries(); } catch (e) {}
            try {
            } catch(e40) {
            }
            v3 %= 2899;
            const o41 = {
            };
            new Proxy(this, o41);
        }
    }
}
new C22();
new C22();
new C22();
new Uint8Array(24);
const t46 = "9007199254740992";
t46["255"] &= 7;
new Uint8ClampedArray();
new Float64Array(631);
let {...v61} = Array(3);
const t51 = (2136873598).constructor;
t51();
([-1,404293594,64,-10]).unshift(1.7976931348623157e+308, -4213);
h = Uint16Array;
new Int8Array(5);
function F74() {
    if (!new.target) { throw 'must be called with new'; }
}
new Int8Array(268435456);
[F74,Uint8Array];
