class C2 {
    static toString(a4, a5) {
        this.d = this;
        const v7 = super[a5];
        try {
            delete this[v7];
            this[C2];
        } catch(e10) {
        }
    }
}
const v11 = new Uint16Array(2554);
new Int32Array(3713);
new Float32Array(3606);
gc();
function F22(a24, a25, a26, a27) {
    if (!new.target) { throw 'must be called with new'; }
    a24.propertyIsEnumerable();
}
const v30 = [601759695];
const v31 = [427812215,61195,-2147483647,4096,-2147483647,30905];
try { v31["find"](..."find", Uint16Array, ...v30, ...v31); } catch (e) {}
const v35 = gc.constructor;
try { v35(gc); } catch (e) {}
class C38 {
    constructor(a40, a41) {
        function f42(a43, a44, a45, a46) {
            return arguments;
        }
        for (let v48 = 0; v48 < 5; v48++) {
            const v49 = f42();
            v49[1] = v49;
        }
    }
}
const v50 = new C38();
v50.constructor;
function F55(a57, a58, a59, a60) {
    if (!new.target) { throw 'must be called with new'; }
    const v61 = this.constructor;
    try { new v61(a57); } catch (e) {}
    this.c = a57;
}
const v64 = Array(1024);
function F66(a68, a69, a70) {
    if (!new.target) { throw 'must be called with new'; }
}
F66();
v11.fuck("flags", "flags", "flags", Float32Array);
const v76 = [-1000000.0,0.1600379490765781,-1.6243694690977962e+307,817210.0157459241,1.0,5.0,0.9202958446582343,-1.7976931348623157e+308,-382.2774365702321,-5.737866676165018e+307];
class C78 {
    static #e;
    m(a80, a81, a82, a83) {
        v76.#e;
        a81.#e = -1;
    }
}
const t57 = Reflect.construct(Uint8ClampedArray, [Uint8ClampedArray]).constructor;
new t57(v64);
