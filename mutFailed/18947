const v0 = /(ab)\1*/vsy;
const v1 = /^l/gvdsy;
const v2 = /J\p{Script=Greek}+/vim;
function f3(a4, a5) {
    const o40 = {
        "a": a4,
        __proto__: a4,
        "d": v1,
        get g() {
            super.b = this;
            v0.sticky;
            return this;
        },
        "e": v2,
        valueOf(a10) {
            return a10;
        },
        get b() {
            function F12(a14, a15, a16, a17) {
                if (!new.target) { throw 'must be called with new'; }
                try {
                    this.h = a14;
                } catch(e18) {
                }
                try {
                    this.a = v1;
                    class C20 extends Map {
                    }
                    new Int32Array(3208);
                } catch(e24) {
                }
                try {
                    this.f = v0;
                } catch(e25) {
                }
            }
            new F12(v1, a5, a5, a4);
            new F12(v0, a4, v2, v2);
            function F28(a30, a31) {
                if (!new.target) { throw 'must be called with new'; }
                try {
                    const v33 = Symbol.iterator;
                    const o35 = {
                        [v33]() {
                        },
                    };
                } catch(e36) {
                }
                try {
                    new F28();
                } catch(e38) {
                }
            }
            const v39 = new F12(a5, a4, a4, v2);
            return v39;
        },
    };
    return o40;
}
function f41() {
    const o45 = {
        "execution": "async",
        "type": "major",
    };
    gc(o45);
    return o45;
}
f3[Symbol.toPrimitive] = f41;
const v49 = f3(v2, v1);
const v50 = f3(v2, v0);
const v51 = f3(v0, v1);
function F52(a54, a55, a56) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.d = a55;
        const v59 = ("boolean").split("toString");
        try {
            this.d = v59;
        } catch(e60) {
            for (let [v61,v62] of v59) {
            }
        }
    } catch(e63) {
    }
    try {
        this.h = a55;
    } catch(e64) {
    }
    try {
        this.e = v51;
    } catch(e65) {
    }
}
const v66 = new F52(v1, v51, v51);
const v67 = new F52(v49, v51, v51);
const v68 = new F52(v67, v50, v49);
function f69(a70, a71, a72, a73) {
    a71[Symbol.toPrimitive] = Symbol;
    const o84 = {
        "c": a72,
        [f3](a77, a78, a79) {
            const v80 = v1[2925];
            for (let v81 = 0; v81 < 100; v81++) {
                f3(a77, a71);
            }
            try { v80(v68, v68); } catch (e) {}
            super.g = v80;
            return v50;
        },
        __proto__: v68,
        "g": a73,
        [F52]: v0,
        "h": v51,
        "a": v51,
    };
    return o84;
}
f69(v49, v0, v67, v51);
f69(v49, v1, v66, v51);
f69(v50, F52, v66, v49);
[9007199254740992,4294967295,10319,65536,0];
[62259,268435456,-2,1073741823,1073741824,50327,11];
[-1024,4294967296,25556];
new Date();
new Set();
function f96(a97) {
    function F98(a100) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v101 = new F98(F98);
    try {
        function f102(a103, a104, a105) {
            let v106 = 0;
            do {
                const o107 = {
                };
                o107.h = v101;
                const o108 = {
                };
                v106++;
            } while ((() => {
                    a105 === 7;
                    try {
                        a104.toString = f102;
                    } catch(e112) {
                        const t4 = [-147676202];
                        t4.length = 1;
                        for (let i116 = 4294967295; i116 < 9;) {
                        }
                    }
                    return v106 < 7;
                })())
            return f102(a105, v101);
        }
        f102();
    } catch(e124) {
    }
    return a97;
}
f96();
