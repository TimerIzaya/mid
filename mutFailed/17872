function f0() {
    const o16 = {
        [6]: "v57tK",
        o(a5, a6) {
            try { a5(this); } catch (e) {}
            const v10 = !5.0;
            !a5;
            const v13 = a5 << (v10 + v10);
            Math.tan(v13);
            Math.fround(v13);
            return a6;
        },
    };
    return o16;
}
const v17 = f0();
const v18 = f0(f0, f0);
const v19 = f0();
1523223443 >>> 1523223443;
class C24 {
    [v19];
    n(a26, a27) {
        const v28 = a27 < a27;
        if (v28) {
            super.h = a26;
        } else {
            try { a26(v28, f0, a26, -4294967296, v28, this); } catch (e) {}
        }
        return 10415;
    }
}
C24.d = C24;
const v30 = new C24();
const v31 = v30?.constructor;
try { new v31(); } catch (e) {}
new C24();
const v34 = new C24();
function f35(a36, a37, a38, a39) {
    a36 + a36;
    a37--;
    ("Vre").charAt();
    try { Uint8Array.from("Vre"); } catch (e) {}
    const v46 = new Uint8Array(a37, -4294967296, Uint8Array, f35);
    for (let v47 = 0; v47 < 5; v47++) {
    }
    let v48;
    try { v48 = v34.n(v19, a37, -4294967296); } catch (e) {}
    const v49 = v30 >> v48;
    v49 * v49;
    C24 && v30;
    const v52 = f0();
    v52[6] = v52;
    %PrepareFunctionForOptimization(f0);
    f0()[6];
    f0();
    %OptimizeMaglevOnNextCall(f0);
    const v56 = f0();
    v56[6] = v56;
    let [v57] = v46;
    return f35;
}
let v58;
try { v58 = v34.n(); } catch (e) {}
v58 + v58;
Object.defineProperty(v18, v58, { writable: true, enumerable: true, value: 1523223443 });
try {
    C24.f = v17;
} catch(e60) {
}
for (let v61 = 0; v61 < 10; v61++) {
    f35(v61, v61, f35, f35);
}
%OptimizeFunctionOnNextCall(f35);
const v64 = f35()?.constructor;
try { new v64(C24); } catch (e) {}
