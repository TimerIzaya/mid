const v0 = /TJ/vsy;
const v1 = /a*b/gdisy;
const v2 = /((a)\1)/usy;
class C3 {
    static #c;
    static get h() {
        try {
            v1.#c = this;
        } catch(e5) {
        }
        return this;
    }
    static [v0] = v0;
    static [v2] = v1;
    6 = v1;
    128 = v0;
    static [-2];
}
C3.name = C3;
const v6 = new C3();
const v7 = new v6();
let v8 = new C3();
v8[128] = v8;
function F12(a14, a15, a16, a17) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.f = a15;
    } catch(e18) {
    }
    try {
        this.h = "-9223372036854775807";
    } catch(e19) {
    }
    try {
        this.e = a17;
    } catch(e20) {
    }
}
const v21 = new F12(v8, "mbh", v2, v6);
const v22 = new F12(v7, v21, v1, v2);
v22.f = v22;
const v23 = new F12(v1, v0, v22, v6);
"o" >>> v23[v23];
C3[8] = "-9223372036854775807";
Math.acosh(v8);
++v8;
let v30 = v8 | v8;
let v31 = v30 ** 268435439;
++v31;
v23.e = v23;
function f33() {
}
f33.arguments = f33;
f33.toString = f33;
function F34(a36, a37) {
    if (!new.target) { throw 'must be called with new'; }
    v30 = a37;
    var e = a37;
    const v41 = this?.constructor;
    try { new v41("mbh", v22); } catch (e) {}
    this[Symbol.toPrimitive] = f33;
    this.a = f33;
}
new F34();
const v46 = new f33();
const v48 = Symbol.toPrimitive;
const v50 = v48.description;
Symbol.for(v50);
v46[v48] = f33;
const t69 = "o";
t69[0] &= 268435439;
Reflect.construct(F12, [v50 in Symbol,Reflect,v22,F34], f33);
