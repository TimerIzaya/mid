class C3 {
    static c;
    constructor(a5) {
        a5.d = a5;
        let v6 = this % a5;
        v6 >> v6;
        let v8 = a5 >>> v6;
        v8 >>> v8;
        16 % 10000;
        [v8,v6] = "getFloat32";
        try {
            v6.length = 1;
        } catch(e12) {
        }
    }
    1;
    static ["getFloat32"] = 16;
}
const v13 = new C3(C3);
const v14 = new C3(16);
const v15 = new C3(v13);
v15[1] = v15;
const v16 = [10000,v15,16,v15];
const v17 = [v13,v14,"getFloat32",v16];
([v16])[0];
class C20 {
    static 1 = v16;
    toString(a22, a23, a24, a25) {
        a24 = a25;
        let v26;
        try { v26 = a23.clear(16, a23, v16); } catch (e) {}
        super.a = a25;
        Reflect.construct(v26, [v26,v26,v14,v17], C3);
        return Reflect;
    }
    static c = v13;
    static [-1];
    [v17];
    static #h = "getFloat32";
}
try { C20.bind(16); } catch (e) {}
new C20();
new C20();
new C20();
function F34() {
    if (!new.target) { throw 'must be called with new'; }
    this.d = -15;
}
const v37 = F34?.constructor;
try { new v37(F34); } catch (e) {}
F34.fuck = F34;
class C39 extends F34 {
}
C39.prototype = C39;
class C40 extends C39 {
    set d(a42) {
        a42 & a42;
        for (const v44 in C39) {
        }
    }
}
const v45 = new C40();
const v46 = v45?.constructor;
try { new v46(); } catch (e) {}
new C40();
