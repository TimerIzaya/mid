const v4 = new Map(-1000000000.0, 2.0, 2.0);
v4.c;
class C6 extends Map {
    static b = -5.0;
    #a = -5.0;
}
new C6();
class C8 extends Map {
    static [-1000000000.0] = -1000000000.0;
    static 4 = -5.0;
    static set g(a10) {
        const v13 = new Set();
        function F14(a16, a17) {
            if (!new.target) { throw 'must be called with new'; }
            try {
                WeakSet.d = a16;
            } catch(e18) {
                for (let [v19,v20] of a17) {
                }
            }
            try {
                const v21 = v13[this];
                ([WeakSet])[1];
                new F14(v21, -268435456n);
            } catch(e26) {
            }
        }
        a10?.[0];
        super[2.0];
        v4[C8];
        super.size = v13;
        for (let v30 = 0; v30 < 32; v30++) {
            a10["p" + v30] = v30;
        }
    }
    static #a;
}
new C8();
const v34 = new C8();
new Map(v34);
new Map();
const v41 = [-8.423288404653653e+307,460.19811044552307,-1.7971213292687213e+308,-1e-15,0.8010499065604265,5.0,1.7976931348623157e+308,-4.0,0.8718051962313597];
let {"size":v42,} = v34;
for (let v43 = 0; v43 < 32; v43++) {
    "object" + v43;
    v4[4294967296] = v43;
}
const v47 = new Uint8ClampedArray(v41);
function f49() {
    return v41;
}
class C50 extends f49 {
    constructor(a52, a53, a54, a55) {
        super();
        function f56() {
            const t55 = [];
            t55[6] = a54;
            v41[3136390630];
            v47.byteOffset;
            return C50;
        }
        for (let v60 = 0; v60 < 5; v60++) {
            f56();
            const o63 = {
            };
            new Proxy(Uint8Array, o63);
            %OptimizeFunctionOnNextCall(f56);
        }
    }
}
const v66 = new C50(Uint8ClampedArray, Uint8ClampedArray, 9007199254740991);
new C50(v66, v41, Uint8ClampedArray, C50);
