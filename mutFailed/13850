let v1 = WeakMap;
let v2 = new v1();
class C3 extends v1 {
    constructor(a5, a6) {
        super(a5);
        try { this.set(this, v1); } catch (e) {}
    }
    a = null;
    p(a9, a10) {
        a10 %= null;
        const v11 = delete v2[64];
        const v15 = a9 / v11;
        -1 ^ v11;
        Math.expm1(v11);
        v2--;
        2147483648 && a9;
        !v15;
        return v2;
    }
}
const v21 = new C3(v2, v2);
const v22 = new C3(v1, v1);
const v23 = new C3(v22, null);
class C24 {
    constructor(a26, a27) {
        v1++;
        C3[1150] *= v1;
    }
    static toString(a30, a31, a32, a33) {
        const v35 = [this,C24,a31];
        Reflect.apply(a32.p, a32, v35);
        return v2;
    }
    #o(a39, a40) {
        v2[a39] **= a39?.c;
        -19042;
        const v45 = +v21;
        let v46 = --C3;
        v45 + v46;
        ~v21;
        v46--;
        return 19042;
    }
}
const v50 = new C24(v23, C3);
new C24(v23, v50);
new C24(v21, v23);
function F53(a55, a56) {
    if (!new.target) { throw 'must be called with new'; }
    this.h = a56;
}
const v57 = new F53(F53, F53);
v50 > v57;
const o64 = {
    "maxByteLength": 256,
};
const v66 = new SharedArrayBuffer(256, o64);
new Int8Array(v66);
/(?!(a))\1/vdim;
delete v57.h;
