class C3 {
    static valueOf(a5, a6) {
        const v7 = async (a8, a9, a10) => {
            'use strict';
            const v11 = [268435456,a5,C3,-529664351,a10];
            [this,[a8,-529664351,v11],v11,-529664351];
            return await -529664351;
        };
        return 268435456;
    }
    static #b = 268435456;
    static h;
    static [-2147483647];
}
try { new C3(); } catch (e) {}
const v16 = new C3();
v16?.constructor;
let v18;
try {
const t0 = 268435456;
v18 = new t0();
} catch (e) {}
const v19 = new C3();
const v20 = new C3(v18, -529664351, -529664351);
const v21 = (-529664351)?.constructor;
try { new v21(); } catch (e) {}
function F23(a25, a26) {
    if (!new.target) { throw 'must be called with new'; }
    this.e = this;
    a26 >>> a26;
    try {
        this.h = v19;
    } catch(e28) {
    }
    try {
        this.e = v19;
    } catch(e29) {
    }
    try {
        this.isConcatSpreadable = v20;
    } catch(e30) {
    }
}
const v31 = new F23(v16, 268435456);
v31.e;
const v33 = new F23(v31, 268435456);
const v34 = new F23(v31, 268435456, F23, v33, 268435456);
const v35 = [v34,v19];
const v36 = [v16,v35,v34];
try { v36.keys(); } catch (e) {}
[v34,-529664351,v16,v34,v35];
const v40 = Int32Array.reduceRight(v33, Int32Array, v16);
v40.prototype;
v40.b;
