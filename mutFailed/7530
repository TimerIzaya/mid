class C3 {
    ["MAX_SAFE_INTEGER"] = -1000000000000.0;
    static 71;
    #h;
    static 5 = -1000000000000.0;
    static [0.0] = 0.0;
    static a = -1000000000000.0;
    static ["MAX_SAFE_INTEGER"] = "MAX_SAFE_INTEGER";
    a;
    static [-1000000000000.0];
    #a = -1000000000000.0;
}
new C3();
const v5 = new C3();
const v6 = new C3();
class C7 extends C3 {
    #valueOf(a9, a10, a11) {
        [a10,a11];
        const v13 = [v6];
        [a10,v5,-1000000000000.0];
        return v13;
    }
    #g;
}
C7.c = C7;
new C7();
new C7();
new C7();
function F21() {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.b = 3;
    } catch(e24) {
    }
    try {
        this.f = 3;
    } catch(e25) {
    }
    try {
        this.h = 3;
    } catch(e26) {
    }
}
const v27 = new F21();
const v28 = new F21();
v28.h;
const v30 = new F21();
const o31 = {
};
o31.h = o31;
const v33 = new Proxy(v30, o31);
v33.b = v33;
const o37 = {
    "execution": "async",
    "type": "minor",
};
gc(o37);
v30.b = v30;
3228 & 3228;
try { Uint32Array.apply(o37, v33); } catch (e) {}
new Uint32Array();
const v46 = new Uint32Array();
const v49 = new Float64Array(10);
v49[1] = v49;
class C50 {
}
try {
    Array(-12302);
} catch(e54) {
}
try { new C50(); } catch (e) {}
const v56 = new C50();
const v57 = v56?.__lookupGetter__;
try { new v57(0.0); } catch (e) {}
const v59 = new C50();
const v60 = [v59,v56,v27];
function F61(a63, a64, a65, a66) {
    if (!new.target) { throw 'must be called with new'; }
    const v67 = this?.__lookupGetter__;
    try { new v67(a63); } catch (e) {}
    try { a63.splice("async", gc); } catch (e) {}
    a64.b = a64;
    let v70;
    try { v70 = a63.entries(); } catch (e) {}
    try { v70.next(); } catch (e) {}
    const v72 = a64?.constructor;
    v72.d = v72;
    try { new v72(); } catch (e) {}
    const v74 = a63.unshift();
    v74 - v74;
    v74 === v74;
    const v78 = new Set();
    const v79 = v78?.keys;
    try { new v79(); } catch (e) {}
    function F81(a83, a84) {
        if (!new.target) { throw 'must be called with new'; }
        try { this.propertyIsEnumerable(a84); } catch (e) {}
        try {
            this.d = a83;
        } catch(e86) {
            for (let [v87,v88] of a83) {
                try {
                    v78.values();
                } catch(e90) {
                }
            }
        }
        try {
            this.h = v78;
        } catch(e91) {
        }
        try {
            const v92 = v78[this];
            try {
                new F81(v92, -268435456n);
            } catch(e95) {
            }
            this.b = Set;
        } catch(e96) {
        }
    }
    const v97 = new F81(Set, Set);
    new F81(Set, F81);
    const v99 = new F81(v97, F81);
    const v103 = [65537,268435441,63298,-5,1235122603];
    const v104 = [128,215394418];
    const v105 = v104.entries();
    const v106 = [-2,-4294967296,4294967297];
    function F107(a109, a110, a111, a112) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v113 = new F107(-714582153, F107, -714582153, v104);
    const v115 = new F81(v99, null);
    new BigUint64Array(0);
    new Int32Array(1519);
    v113.length;
    const v123 = new F107(9, v113, 9, v106);
    v123.b = v123;
    new F107(1024, v123, v106, v106);
    const v132 = ("string").trimStart();
    new Int16Array(2);
    const v137 = new Uint32Array(16);
    for (const v138 in v137) {
        this.escape(v138);
    }
    v105[3];
    let v144;
    try { v144 = v132(); } catch (e) {}
    v103[v144] = v104;
    0 ^ 9;
    const v149 = -1000;
    ~9;
    v149 >>> v149;
    a = ("string").length - F107;
    v78[v123];
    v115.__proto__;
    -35417 - -35417;
}
F61.length;
const v159 = new F61(v60, v28);
new F61(v60, v46, v46, v159);
