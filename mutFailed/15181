function f3(a4) {
    a4.toString = f3;
    a4 !== a4;
    const o12 = {
        3: -166444923,
        o(a7, a8) {
            %VerifyType(this);
            new WeakSet();
            return -166444923;
        },
        "a": a4,
        [a4]: -25572,
        "f": a4,
        "g": -166444923,
        "d": 10,
        get c() {
            return this;
        },
        __proto__: a4,
        "execution": -166444923,
    };
    o12[Symbol.toPrimitive] = f3;
    return o12;
}
const v15 = f3(10);
const v16 = f3(-25572);
const v17 = f3(v16);
v17.length = v17;
class C18 extends f3 {
    o(a20, a21) {
        const v26 = (268435440 && this) & 268435440;
        const v27 = ~v15;
        a21 & v26;
        Math.sign(v27);
        return a21;
    }
    #d;
    1073741824 = -166444923;
    4 = v16;
    static [10];
    static #f = f3;
    static #b = -166444923;
}
const v30 = new C18();
-166444923 == 268435440n;
function f34() {
    try {
        v30.o(v17, false, -2147483649n);
    } catch(e38) {
    }
    return v16;
}
Date[Symbol.toPrimitive] = f34;
try { Date.now(); } catch (e) {}
const v42 = new Date(Date);
v42.setDate();
new C18();
const v45 = [];
v45.toString = Date;
try { v45.toString(); } catch (e) {}
v45[6] = -166444923;
function f48(a49, a50) {
    return 536870912;
}
new C18();
try { new Float32Array(v17, Float32Array, v17); } catch (e) {}
const v55 = new Float32Array();
try { v55.entries(); } catch (e) {}
for (let v57 = 0; v57 < 25; v57++) {
    v57 % v57;
    function f59(a60, a61, a62, a63) {
        try { a60.entries(); } catch (e) {}
        const v65 = a60[1];
        const o67 = {
        };
        o67.c = o67;
        536870912n ^ 536870912n;
        return 536870912n;
        function F71() {
            if (!new.target) { throw 'must be called with new'; }
            Reflect.preventExtensions(Worker);
        }
        new F71();
        let v79 = new Date();
        v79 **= v79;
        v65?.["4294967296"];
        for (let v81 = 0; v81 < 32; v81++) {
            const t87 = "-4096";
            t87["p" + v81] = v81;
        }
        a61--;
        a60[0] = a60;
        a61 <= a61;
        arguments[1] = arguments;
        const v87 = arguments?.__lookupGetter__;
        try { v87.constructor(v55, a62, v57, f59); } catch (e) {}
        (v17 & arguments) + v30;
        let v94;
        try { v94 = v87(v87, f59, a61); } catch (e) {}
        return v94;
    }
    for (let v95 = 0; v95 < 10; v95++) {
        f59(v55);
    }
}
