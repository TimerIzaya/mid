const v3 = [15999n,15999n,15999n,1977332783n,15999n];
[1977332783n,v3,v3];
const v5 = [15999n,15999n,-1636645893n,v3];
[v3];
[-1636645893n];
[v5];
const v11 = new SharedArrayBuffer();
new DataView(v11, v11, v5);
class C14 {
}
Date.now();
class C22 {
    constructor(a24, a25) {
    }
}
const v27 = new C22();
v27 << -1557853178;
const v31 = new Float32Array(Float32Array, Float32Array, Float32Array);
function f32() {
    v31.c = Float32Array;
    for (let v33 = 0; v33 < 5; v33++) {
        class C36 {
        }
        function f37() {
            return f37;
        }
        const o38 = {
        };
        o38[Uint32Array] -= -2147483649;
        class C39 {
        }
        new BigUint64Array(v33, v33, v33);
    }
    return f32;
}
%PrepareFunctionForOptimization(f32);
Symbol();
const v45 = new SharedArrayBuffer(SharedArrayBuffer, SharedArrayBuffer);
v45.byteLength;
const v47 = f32();
v47[Date] = v47;
[510.2053105196128,0.8358186694591268,1.0,0.543725476488796,-Infinity,5.0,700.6383739635098,Infinity,3.0] ^ "-792442332";
const o51 = {
    "d": SharedArrayBuffer,
};
%OptimizeFunctionOnNextCall(f32);
Object(10).toExponential(-28050);
const v58 = new Float64Array(255);
function F59(a61, a62, a63, a64) {
    if (!new.target) { throw 'must be called with new'; }
    a62 >> a62;
    a64 | a64;
    try {
        v58.b = a62;
    } catch(e67) {
    }
    try {
        this.h = a61;
    } catch(e68) {
    }
}
f32();
