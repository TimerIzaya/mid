let v3 = 7;
const v4 = v3++;
const v6 = new Uint16Array(v3);
const v9 = new Uint32Array(9);
try { new Uint32Array(9, 9, 8); } catch (e) {}
new Uint32Array(631);
function f14() {
}
const o15 = {
};
function F16(a18, a19, a20, a21) {
    if (!new.target) { throw 'must be called with new'; }
    2105444095n * 2105444095n;
    const v25 = 2105444095n / 2105444095n;
    const v26 = v25 << v25;
    for (let v27 = 0; v27 < 100; v27++) {
        v27 >>> v27;
        const o42 = {
            6: undefined,
            toString(a31, a32) {
                try { a31.o(v26, v4, a20, a32, o15); } catch (e) {}
                ~(464.8500133097375 >>> (Uint16Array >> Uint16Array));
                return 5 % 5;
            },
            "d": undefined,
            [268435439n]: 2105444095n,
            __proto__: o15,
            "g": a20,
        };
        delete a18?.[v27];
        (this - -5) >> (this && -5);
        let v49 = 2105444095n + -5;
        const v50 = --v49;
        ~v50;
        Math.fround(v50);
        o42[268435439];
    }
    const o54 = {
        "getOwnPropertyDescriptor": f14,
    };
    Proxy.a = Proxy;
    const v56 = new Proxy(this, o54);
    v56.h = v56;
}
new F16();
const v58 = new F16();
v58.h;
const v60 = v58.constructor;
try { new v60(f14, f14, v6, f14); } catch (e) {}
new v60();
const v63 = new F16();
const v64 = v63.constructor;
try { v64(F16, v9, v64, v9); } catch (e) {}
const v66 = new v64();
v66.h = v66;
