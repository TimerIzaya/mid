let v2 = new Uint8ClampedArray(3790);
const v5 = new Float32Array(16);
new Uint8Array(249);
class C9 extends Uint8ClampedArray {
    5;
    m(a11, a12) {
        super.buffer;
        super.g = Uint8Array;
        return a11;
    }
    static #toString(a18, a19) {
        new Float32Array(a18, a18, 16);
        super[v2];
        super.length;
        v2 *= v2;
        return Float32Array;
    }
}
const v23 = new C9();
const v24 = new C9();
const v25 = new C9();
function f26(a27, a28) {
    const o32 = {
        [3790]: a27,
        get b() {
            const v30 = new C9();
            v30[1] = v30;
            this[this] %= v2;
            %VerifyType(v30);
            try {
                v24.__proto__ = v5;
            } catch(e31) {
            }
            return 16;
        },
        "b": a28,
        8: a28,
        [Uint8ClampedArray]: v23,
    };
    return o32;
}
const v33 = f26(v25, 3790);
f26(v25, v2);
function f35(a36, a37, a38) {
    const o39 = {
        [v33]: v2,
        "h": a37,
    };
    return o39;
}
f35(Uint8ClampedArray, 3790, v24);
f35(Float32Array, v2, v25);
f35(f26, 249, v25);
f26(v25, v2);
let v45 = undefined;
const o46 = {
};
f26(3790, o46);
%PrepareFunctionForOptimization(f26);
f26(3790, o46);
f26(3790, o46);
%OptimizeFunctionOnNextCall(f26);
f26(3790, o46);
v45 = o46;
function F54(a56, a57, a58) {
    if (!new.target) { throw 'must be called with new'; }
    const v59 = this.constructor;
    try { new v59(a56, -1000000000000.0); } catch (e) {}
    a57 % a57;
    this.a = a56;
}
new F54(2.220446049250313e-16);
const v63 = new F54();
class C64 extends F54 {
    65537 = v45;
    7 = v63;
}
new C64();
new C64();
new C64();
