let v1 = "uOS";
let v2 = -1.3011221991393085e+308;
class C3 {
    f = 5;
    n(a5) {
        super.c;
        try {
            super.m();
        } catch(e8) {
        }
        a5 && C3;
        super[v2] = a5;
        return this;
    }
    static [v2] = v1;
    g;
}
let v13 = new C3();
new C3();
const v15 = new C3();
v13--;
v13[4096] = "fill";
let v19 = delete v15[2147483648];
({"b":v19,"g":v1,"length":v13,...v2} = "fill");
const v21 = [v19];
const v22 = ("fill").search;
let v23 = 0;
while (v23 < 3) {
    let [v26] = v22;
    v23++;
}
Reflect.apply(v22, v2, v21);
let v32 = "number";
class C33 extends C3 {
    static #n(a35, a36) {
        const v37 = v2;
        try {
            Reflect % 5;
            Math.cosh(C3);
            const v43 = !C3;
            const v44 = +C3;
            -3.911383822897296 ^ v43;
            v43 & v44;
            -Reflect;
            const t42 = "map";
            t42.length = -3.911383822897296 & 9262;
        } catch(e49) {
        }
        return a35;
    }
}
new v15();
new v22();
new C33();
const v59 = v32++;
-2051922884 >> -2051922884;
const v61 = v32 || v59;
Math.sign(-2051922884);
Math.asinh(v32);
v22.log10(v61);
function F65(a67, a68) {
    if (!new.target) { throw 'must be called with new'; }
    Number.isFinite(Number);
    const v71 = this.constructor;
    try { new v71(); } catch (e) {}
}
new F65();
new F65();
