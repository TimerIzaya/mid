const v0 = [17734,10,561492040,8,7,2147483648];
const v1 = [503193933,-733088143,4096,-9223372036854775808,65537,-198783846,-1951436517];
const v2 = [-9007199254740991];
class C3 {
    0 = v2;
    static {
        this - v1;
    }
    h = v1;
    static set g(a7) {
        const v10 = v1[Symbol.replace];
        super[v10] = v10;
        v0 - v1;
        a7[255] ||= a7;
    }
}
new C3();
new Date();
function F15(a17) {
    if (!new.target) { throw 'must be called with new'; }
    a17 ^ a17;
}
new C3();
const v20 = new C3();
new Uint8Array(1024);
function F24(a26) {
    if (!new.target) { throw 'must be called with new'; }
    const v27 = this.constructor;
    try { new v27(a26); } catch (e) {}
    try {
        a26 % 257;
    } catch(e31) {
    }
}
new F24(F24);
class C33 {
    valueOf(a35, a36, a37, a38) {
        try {
            v2.length = a38;
        } catch(e39) {
        }
        return C3;
    }
    static #d;
    static 7 = v0;
    [v2] = v1;
    static #f = F24;
    268435439;
    512 = v1;
    static #b;
    536870887 = v20;
    5;
}
new C33();
new C33();
new C33();
class C46 {
    constructor(a48, a49, a50) {
        super(v1);
    }
}
function f51(a52, a53) {
}
f51.prototype = f51;
%OptimizeFunctionOnNextCall(f51);
f51();
function F55(a57, a58, a59) {
    if (!new.target) { throw 'must be called with new'; }
    const v60 = this.constructor;
    try { new v60(a59, C46); } catch (e) {}
    a57 % a57;
}
(3.0).toExponential(64);
if (v20) {
}
new F55(820, 121, 129);
new F55(820, 121);
