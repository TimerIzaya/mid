let v0 = "g";
let v2 = 3.0;
class C3 {
    1855;
    constructor(a5, a6, a7) {
        const v8 = a7.concat();
        v8[1] = v8;
    }
    m(a10, a11) {
        return v0[Symbol.asyncIterator];
    }
    set g(a16) {
        super[v2] = a16;
        C3?.[super[v2]];
        const v20 = new String(v0);
        const v21 = v2 in v20;
        const v23 = Symbol.toPrimitive;
        const o29 = {
            [v23]() {
                try { a16(a16, -281480.20657365886, this, this); } catch (e) {}
                for (let v26 = 0; v26 < 32; v26++) {
                    Symbol["p" + v26] = v26;
                }
                return v0;
            },
            [C3]: v23,
            "a": v21,
            [v20]: v20,
            __proto__: this,
            "g": String,
        };
        class C30 {
            static d = C3;
            static [-281480.20657365886];
            [-281480.20657365886] = C3;
        }
        new C30();
        new C30();
        new C30();
    }
}
const v34 = new C3();
v2 -= v2;
v0[C3] = v34;
const v37 = ~v2;
242119959 * v37;
Math.atan2(v34, v37);
new C3();
const v41 = new C3();
const v44 = new Int16Array(129);
delete v41[255];
new Uint8ClampedArray(v44, 129, 129);
new C3();
v0 += v0;
v44.buffer;
new Uint8ClampedArray(4096);
new Float32Array(71);
function F55() {
    if (!new.target) { throw 'must be called with new'; }
    const v58 = [F55,F55];
    [v58,1141300185,F55];
    let v60 = [this];
    Math.log2(v58);
    const v64 = v60++;
    v64 ^ v64;
    Math.asinh(536870887);
    try {
        class C68 extends this.constructor {
            e = F55;
        }
        C68.caller;
        new C68();
    } catch(e71) {
    }
}
new F55();
new F55();
new F55();
