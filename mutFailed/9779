function f0() {
}
const v1 = [129];
const o2 = {
};
function F6(a8, a9) {
    if (!new.target) { throw 'must be called with new'; }
    a8.trimLeft().strike();
    const v12 = this.constructor;
    try { new v12("a", "a"); } catch (e) {}
}
new F6("-2147483648", "yRMy");
const v15 = [4294967296,3,2147483649,257,-7806];
const v16 = [1497859724,2147483648,7,-9007199254740992,3,14,3758,4294967295,-9];
new Uint8Array(512);
let v20 = 4.150176177212824;
v20 &= -2.0;
class C22 {
    o(a24) {
        v15[5] >>= a24;
        this[v1] = v1;
        try {
            v15.toString();
            class C26 {
            }
            const t25 = "9007199254740992";
            t25["255"] &= 7;
            for (const v30 in "9007199254740992") {
            }
        } catch(e31) {
        }
        return this;
    }
    h = v16;
    #n(a33, a34, a35, a36) {
        return v16;
    }
    ["yRMy"] = 512;
    #n(a38, a39) {
    }
}
const v40 = new C22();
const v41 = new C22();
new C22();
function F43(a45, a46) {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.e = f0;
    } catch(e47) {
    }
    try {
        this.f = v41;
    } catch(e48) {
    }
}
new F43(v40, v16);
const v50 = new F43(C22, v16);
new F43(v50, v15);
new BigUint64Array();
SharedArrayBuffer();
const v58 = new Int32Array(1024);
for (const v59 of v58) {
    const o61 = {
    };
    gc(o61);
    new SharedArrayBuffer(1024);
}
class C65 {
}
const v66 = new C65();
const v67 = new C65();
class C68 {
    static #a = C65;
    static g = v67;
    static {
        delete this.g;
    }
}
const v73 = new Uint32Array(4);
new Float64Array(v73);
delete v66[512];
