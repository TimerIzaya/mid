class C3 {
    static #m(a5) {
        try {
        const t0 = 33149;
        new t0(a5, 33149, C3);
        } catch (e) {}
        const v8 = super[WeakRef];
        a5 ^ v8;
        super.g;
        try { v8.m(this); } catch (e) {}
        return WeakRef;
    }
    [33149] = -256;
    e = -256;
    0 = -256;
    a;
    [-256] = 33149;
}
const t18 = 2997;
const v12 = new t18();
new C3();
new C3();
class C15 extends C3 {
    static p(a17, a18) {
        const v19 = C3.b;
        super[C3] = a18;
        let v20 = 0;
        do {
            function F21(a23, a24, a25) {
                if (!new.target) { throw 'must be called with new'; }
                try {
                    this.g = v19;
                } catch(e26) {
                }
            }
            const v27 = new F21(C3, -256, v20);
            new F21(v19, v27, -256);
            new F21(v12, v19, 33149);
            v20++;
        } while (v20 < 1)
        return a17;
    }
}
new C15();
new C15();
new C15();
function f36() {
    return -256;
}
const v38 = new Date();
function f40() {
    for (let v41 = 0; v41 < 5; v41++) {
        const v42 = [1073741824,1073741823,1376142744,1073741825];
        for (let v43 = 0; v43 < 5; v43++) {
            const v44 = v42;
            (-256)[3];
            v42[32] = 56;
            try {
                Math.ceil(("find" + 15) / 15);
            } catch(e52) {
            }
            try { v42["find"](); } catch (e) {}
        }
    }
    return 56;
}
f40();
%OptimizeFunctionOnNextCall(f40);
v38();
