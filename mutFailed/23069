function F0() {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.a = 16;
    } catch(e3) {
    }
    try {
        this.b = 16;
        this < 16;
        const v5 = ++F0;
        Math.log2(v5);
        +16;
        9007199254740992 ** v5;
    } catch(e12) {
    }
}
new F0();
new F0();
new F0();
285 % 285;
new Uint16Array(285);
const v23 = new Int32Array();
let v25 = 129;
v25 >> v25;
const v28 = new Uint8ClampedArray(v25);
const v29 = new Int32Array(3208);
let v30;
try { v30 = v29.reduce(281); } catch (e) {}
const t28 = v23.constructor;
new t28(v28);
const v33 = Int32Array.from(v29);
try { v33.slice(281, v29); } catch (e) {}
const v35 = new Int16Array(281);
v35[235];
BigUint64Array.d = BigUint64Array;
new BigUint64Array(10);
class C40 {
}
const v41 = new C40();
function F42() {
    if (!new.target) { throw 'must be called with new'; }
    try { this.propertyIsEnumerable(this); } catch (e) {}
    const v46 = new Uint32Array();
    let v47;
    try { v47 = v46.copyWithin(3208, v29); } catch (e) {}
    for (let v48 = 0; v48 < 5; v48++) {
        v46[v48] = v41;
    }
    try {
        const v49 = this.constructor;
        v23.__proto__;
        v25 = v30;
        try {
            this.h = v47;
        } catch(e51) {
        }
        const o56 = {
            get e() {
                v46.buffer %= 10;
                function f53() {
                    return v46;
                }
                try {
                    f53();
                } catch(e55) {
                }
                return v49;
            },
        };
        0.033437543729764596 === 0.033437543729764596;
        Math.atanh(0.033437543729764596);
        class C61 extends v49 {
            e = F42;
        }
        new C61();
    } catch(e63) {
    }
}
new F42();
new F42();
