const v5 = new Uint16Array(128);
const v8 = new Int16Array(6);
Uint32Array[1] = -376498.8199279986;
const v11 = new Uint32Array(86);
class C12 extends Int16Array {
    m(a14, a15) {
        a14 = 1.6286064980524535e+308;
        return this;
    }
    constructor(a20, a21, a22) {
        a20[1] = -376498.8199279986;
        super(a20);
        try { a20(v5, a22, a20, v8, a21); } catch (e) {}
        this["pCk1"];
        const o28 = {
        };
        new Proxy(v8, o28);
    }
}
new C12(Uint32Array, 4.2127286749195657e+307, 1.6286064980524535e+308);
new C12(6, 4.2127286749195657e+307, 1.6286064980524535e+308);
new C12(v11, 1.6286064980524535e+308, 1.6286064980524535e+308);
function F34() {
    if (!new.target) { throw 'must be called with new'; }
    try {
        this.e = -2147483647;
    } catch(e37) {
    }
}
const v38 = new F34();
const v39 = new F34();
const v40 = new F34();
function f41() {
    const v42 = [268435440,8,7,1073741824,2147483647,70520590,-9223372036854775807,129,268435439,-1147002105];
    return v42.concat(v42);
}
v40[Symbol.iterator] = f41;
function F46(a48) {
    if (!new.target) { throw 'must be called with new'; }
    this[Symbol.split] = Symbol;
    const v51 = a48?.constructor;
    try { new v51(); } catch (e) {}
    try {
        this.g = a48;
    } catch(e53) {
    }
}
F46.arguments;
const v56 = Symbol.iterator;
const o65 = {
    [v56]() {
        let v58 = 10;
        const o64 = {
            next() {
                v58--;
                const v62 = v58 == 0;
                const o63 = {
                    "done": v62,
                    "value": v58,
                };
                return o63;
            },
        };
        return o64;
    },
};
o65.c = o65;
const v66 = new F46(v40);
const v67 = new F46(v39, v66);
function f68() {
    return F46;
}
const v69 = f68.prototype;
Math[256];
try { new BigInt64Array(v40, BigInt64Array, v67); } catch (e) {}
new BigInt64Array(128);
new Uint16Array(3171);
let v79 = 9;
new Uint16Array(v79);
let v82 = 7;
v82--;
function f86(a87, a88) {
    v79 = a88;
}
new Promise(f86);
const v91 = f68++;
Math.cbrt(v91);
const v93 = Math.asin(v91);
const v94 = new F46(v39);
function f95(a96, a97) {
    v5[a96];
    Math[9];
    return v69;
}
v94[Symbol.split] = f95;
function F102(a104, a105, a106) {
    if (!new.target) { throw 'must be called with new'; }
    this.c = a105;
    a105.a = 86;
    const v107 = this?.__lookupGetter__;
    try { new v107(Uint16Array); } catch (e) {}
    a105.a = a105;
    try {
        this.a = v66;
        try { new Symbol(); } catch (e) {}
        const v111 = Symbol.split;
        Symbol.for(v111.description);
        v94[v111];
        const v116 = typeof a106;
        v116[0] = v116;
        ("Qhn")[0];
        v116 === "Qhn";
    } catch(e120) {
    }
    try {
        this.c = v40;
    } catch(e121) {
    }
}
F102.arguments = F102;
new F102(v66, v40, v38);
new F102(v66, v39, v40);
new F102(v66, v40, v38);
const v125 = [65536,616125741,39049,129];
([536870888,2147483649])[1];
[1723484275,-249128090];
[];
class C130 {
    constructor(a132) {
        this.constructor = Symbol;
        this.constructor;
        function F136() {
            if (!new.target) { throw 'must be called with new'; }
        }
        class C138 {
            constructor(a140, a141, a142) {
                a141.constructor = gc;
                class C144 extends a141.constructor {
                }
                new C144();
            }
        }
        new C138(F136, C138);
        const v147 = new WeakSet();
        try { v147.add(a132); } catch (e) {}
        for (let v149 = 0; v149 < 5; v149++) {
            v149 >>> v149;
        }
        a132++;
    }
}
function f152(a153) {
    a153[a153] ^= v93;
    new Float64Array(87);
    new Int32Array(257);
    new Uint8Array(179);
    return v125;
}
C130[Symbol.toPrimitive] = f152;
new C130();
new C130(C130);
