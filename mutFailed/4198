function f0() {
}
let v1 = [NaN,1000000.0,-689571.4512560454,NaN,1000000.0];
const v2 = [-9.371693132715269,-6184.527183899889,858203.0032277706,7.3247425511230055,Infinity,0.18252098951312723,-1000000.0,292.1865395574587,-1000000000000.0,1e-15];
[-1.2945625656474036,2.220446049250313e-16,8.351849623601346,-2.2250738585072014e-308,888599.806877841,-5.5602033445569194,-1000000000000.0,4.087708834055533];
const v4 = [-3.0,-805.6719120878117,2.2250738585072014e-308,-15.356586820940379,0.13930476915297463,1.7976931348623157e+308,5.0,-1000000.0,0.37430340245302196,1000000.0];
[-2.0,4.0,585.0405177621587,-Infinity,0.829289920183706,-229.14434667669605];
[161.81025414630471];
class C10 {
    static 3909761 = v1;
    static {
        Object.defineProperty(v4, 144, { writable: true, enumerable: true, get: f0 });
        v1 /= this;
        f0();
        %PrepareFunctionForOptimization(f0);
        f0();
        f0();
        %OptimizeMaglevOnNextCall(f0);
        f0();
    }
    #e = v2;
    m(a17, a18, a19, a20) {
        this[Symbol.isConcatSpreadable];
        return a20;
    }
}
const v24 = new C10();
new C10();
new C10();
function f27(a28, a29, a30, a31) {
    function F32(a34, a35, a36, a37) {
        if (!new.target) { throw 'must be called with new'; }
    }
    const v38 = new F32();
    const v39 = new F32(f27, f27, a29, v38);
    v24[Symbol.hasInstance] = 2145121456n;
    function f42() {
        return v38;
    }
    v39 in v38;
    return f27;
}
for (let v44 = 0; v44 < 10; v44++) {
    f27(v44, f27, v44, f27);
}
%OptimizeFunctionOnNextCall(f27);
f27();
