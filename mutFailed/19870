class C1 {
}
function f3() {
    function f4(a5, a6, a7, a8) {
        try { ("Vre").search(arguments); } catch (e) {}
    }
    return f4;
}
Float32Array[Symbol.iterator] = f3;
const v14 = new Float32Array(Float32Array, Float32Array, Float32Array);
async function f16(a17, a18, a19) {
    v14.h = v14;
    await 160;
    return f16;
}
for (let v22 = 0; v22 < 5; v22++) {
}
class C26 {
    static e;
    constructor(a28, a29) {
        this?.constructor;
        a29 - a29;
        -4.0 !== -1e-15;
    }
    static get d() {
        for (let v34 = 0; v34 < 16; v34++) {
        }
        try {
        } catch(e35) {
        }
    }
}
const v36 = new Float32Array(129);
new Float32Array(12);
new Float32Array(512);
function f43() {
    return v36;
}
function F44() {
    if (!new.target) { throw 'must be called with new'; }
}
const v46 = new F44();
const t42 = [v46];
delete t42?.length;
const o50 = {
};
const v52 = new Date();
v52.getUTCDate();
function f56(a57, a58) {
    function f59() {
        return f43;
    }
    Object.defineProperty(a57, "toString", { configurable: true, get: f59 });
    ([a57,a57]).at(a57);
    class C64 extends (472608997).constructor {
    }
    new C64();
    return f56;
}
%PrepareFunctionForOptimization(f56);
const v66 = f56(f56, f56);
function f67(a68, a69) {
    for (let v70 = 0; v70 < 100; v70++) {
        Symbol(a69);
    }
    return a68;
}
v66.toString = f67;
%OptimizeFunctionOnNextCall(f56);
f56(f56, v66);
