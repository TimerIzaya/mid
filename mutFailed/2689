const v9 = [-2147483647,64098,-9383,1024,129,-5];
let v10;
try { v10 = v9.pop(); } catch (e) {}
class C11 {
    [v9] = -1000000.0;
    constructor(a13, a14, a15, a16) {
        this[1];
        a15 / a15;
        %VerifyType(a16);
        super[this];
    }
    g;
    c;
    #toString(a21, a22, a23) {
    }
    1 = 65535n;
}
const v24 = new C11(1073741825n, 1.0, 7.589647165982214);
function F27(a29, a30, a31) {
    if (!new.target) { throw 'must be called with new'; }
}
new F27(65535n, 35066, -65537);
v24[1] = v24;
const v34 = new BigUint64Array(5);
try { v34.values(); } catch (e) {}
1000 + 1000;
new BigUint64Array(1000);
class C41 {
    set g(a43) {
        class C44 {
        }
    }
}
try { v34.findIndex(v10, v34); } catch (e) {}
v10 | -65536n;
new BigInt64Array(16);
const v54 = Math.tan(-1);
127 >>> 127;
class C59 {
    #m(a61, a62) {
        function f63() {
            return a62;
        }
        super[a62] = "f";
        %VerifyType(a62);
        return f63;
    }
    m(a65, a66) {
        const o69 = {
            "maxByteLength": 64,
        };
        const v71 = new ArrayBuffer(64, o69);
        const v73 = new Float64Array(v71);
        return v73;
    }
    static c;
}
new C59();
const v75 = new Uint8Array(127);
const t59 = (-1).constructor;
new t59();
function F79(a81, a82, a83, a84) {
    if (!new.target) { throw 'must be called with new'; }
    const v85 = this?.__defineGetter__;
    try { v85(undefined, undefined); } catch (e) {}
    try { a81.unshift(a82); } catch (e) {}
    a83 != a83;
    let v89;
    try { v89 = a81.toSpliced(a82, a82); } catch (e) {}
    const v90 = v89?.__defineSetter__;
    try { v90(); } catch (e) {}
}
try { v75.indexOf(v54); } catch (e) {}
Uint32Array.name;
([16,-1073741824n]).flat(16);
let v99 = 268435440n;
--v99;
new Uint32Array(v75);
