class C3 {
    constructor(a5) {
        a5 | a5;
        a5 + a5;
        try { this.isArray(1011250639, this, -2, this); } catch (e) {}
        try {
            super.p();
        } catch(e10) {
            const v11 = e10.message;
            v11[37] = v11;
        }
    }
    set g(a13) {
        const v14 = this?.constructor;
        try { new v14(C3); } catch (e) {}
        a13.length = a13;
        Object.defineProperty(this, 1000, { writable: true, configurable: true, value: a13 });
        let v16;
        try { v16 = a13(1011250639, this, 1011250639, this); } catch (e) {}
        class C17 {
            static [a13];
            static 10 = v16;
        }
        C17[10] = C17;
        new C17();
        const v19 = new C17();
        const v20 = v19?.constructor;
        try { new v20(); } catch (e) {}
        const v22 = new C17();
        const v23 = v22?.constructor;
        try { new v23(); } catch (e) {}
    }
}
try { new C3(C3); } catch (e) {}
C3.a = C3;
new C3(1011250639);
const v27 = new C3(1011250639);
const v28 = new C3(1011250639);
v28.g = v28;
function F29(a31, a32) {
    if (!new.target) { throw 'must be called with new'; }
    const v33 = this?.constructor;
    try { new v33(a32, this); } catch (e) {}
    const v35 = a31 / a31;
    v35 ^ v35;
    try {
        this.d = a31;
    } catch(e37) {
    }
    try {
        this.g = v27;
    } catch(e38) {
    }
    try {
        this.a = a31;
    } catch(e39) {
    }
}
F29.d = F29;
new F29(-145528610, 1011250639);
new F29(-145528610, -145528610);
new F29(-2, -145528610);
Float32Array.prototype = Float32Array;
const v45 = new Float32Array(0);
try { v45.entries(); } catch (e) {}
try { v45.set(C3); } catch (e) {}
512 & 512;
new Int32Array(512);
const v53 = 2529 !== 2529;
v53 && v53;
const v56 = new Uint32Array(2529);
let v57 = v56[355];
v57--;
const v60 = [1000,1000,1000,1000,1000];
try { v60.values(); } catch (e) {}
for (let i = 0; i < 5; i++) {
    Object.defineProperty(v60, 130, { value: 1000 });
}
