Uint32Array[1] = Uint32Array;
const v2 = new Uint32Array(8);
function f3(a4, a5) {
    a4.valueOf = f3;
    try { new a4(a4, a5, f3); } catch (e) {}
    a5.caller = a5;
    a4[v2] >>= a4;
    16 >>> 16;
    return -17930;
}
let v11 = f3(Uint32Array, f3);
v11--;
Int32Array.d = f3;
Int32Array.d = Int32Array;
const v15 = new Int32Array(6);
try { v15.entries(); } catch (e) {}
new Int8Array(1);
Uint8Array.toString = f3;
new Uint8Array(1205);
try { Uint8Array.toString(); } catch (e) {}
new Uint8Array(129);
212 >> 212;
new Float32Array(212);
class C32 {
}
function F35(a37, a38) {
    if (!new.target) { throw 'must be called with new'; }
    const v39 = this.constructor;
    v39.g = v39;
    try { new v39(); } catch (e) {}
    this.c = a37;
}
F35.g = -39471n;
const v42 = new Uint8Array(268435440);
try { v42.entries(); } catch (e) {}
Uint8ClampedArray.BYTES_PER_ELEMENT = Uint8ClampedArray;
const v46 = [C32];
new F35(v46, v42);
new Uint8ClampedArray(129);
v46.length = 18074;
function F49(a51, a52, a53) {
    if (!new.target) { throw 'must be called with new'; }
    Object.defineProperty(this, "constructor", { writable: true, configurable: true, enumerable: true, value: f3 });
    a52 === a52;
    this.constructor;
}
function f56() {
    class C57 {
    }
    const v58 = new C57();
    for (let v59 = 0; v59 < 5; v59++) {
        new F49(undefined, v58);
    }
}
%PrepareFunctionForOptimization(f56);
f56();
%OptimizeFunctionOnNextCall(f56);
f56();
