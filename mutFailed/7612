const v3 = [16];
const v4 = [v3];
const v5 = [16,8,v4,16];
class C6 {
    static [8];
    1744;
    [8];
    #f = v3;
    constructor(a8, a9, a10, a11) {
        let v12;
        try { v12 = this.p(this, a9); } catch (e) {}
        try { v12(256); } catch (e) {}
        throw a9;
    }
    e = v4;
    [v5] = 8;
    static #b;
}
const v14 = new C6(C6, 256, 256, 256);
new C6(256, 256, 256, 256);
new C6(v14, 8, 8, 16);
const v19 = new BigUint64Array(229);
new BigInt64Array(64);
new Uint8Array(240, BigInt64Array, v19, BigInt64Array);
("minor").valueOf();
class C29 {
    ["minor"] = 0.9009832213714677;
}
const v30 = new C29();
function f31(a32, a33, a34, a35) {
    v30.minor;
    const v38 = Math.sign(a33);
    v38 >>> v38;
    return a32;
}
for (let v40 = 0; v40 < 10; v40++) {
    f31(C29, v40, v30, "minor");
    function F42() {
        if (!new.target) { throw 'must be called with new'; }
    }
}
%OptimizeFunctionOnNextCall(f31);
f31(BigInt64Array);
