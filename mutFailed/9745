function F0() {
    if (!new.target) { throw 'must be called with new'; }
    try {
        const t3 = 8;
        t3.a = 8;
    } catch(e3) {
    }
    try {
        this.e = 8;
    } catch(e4) {
    }
    try {
        this.c = 8;
    } catch(e5) {
    }
}
const v6 = new F0();
const v7 = new F0(F0, v6);
const v8 = new F0();
function f9() {
    return v6;
}
new Uint8ClampedArray(-961119257);
const v15 = new Uint16Array(Uint16Array, Uint16Array, Uint16Array);
const v18 = new Int32Array(v15, 10);
class C19 {
    static #d = 10;
    constructor(a21, a22) {
        try {
            v15.#d += v18;
        } catch(e23) {
        }
    }
}
const v24 = new C19(v18, v15);
new Int8Array(0);
const v29 = new Uint8Array(Uint8Array);
function f30(a31, a32, a33) {
    const o38 = {
        __proto__: v8,
        [-1]: a33,
        "growable": F0,
        get b() {
            this[a32] = 114;
            typeof a32 > "string";
            return this;
        },
        "h": a32,
        "callee": v24,
        "b": v8,
        "e": a31,
        [a33]: v29,
    };
    return o38;
}
f30(v7, 114, 0);
f30(v8, 114, -961119257);
f30(v8, -961119257, -961119257);
const v42 = [-9223372036854775808];
function F43(a45) {
    if (!new.target) { throw 'must be called with new'; }
    try { a45.groupToMap(a45, F43, v42, this, F43); } catch (e) {}
    try {
        this.d = v42;
    } catch(e47) {
        for (let v48 = 0; v48 < 5; v48++) {
        }
    }
}
try { ("d").includes(F43); } catch (e) {}
