class C3 {
    static #m(a5) {
        let v4 = this;
        try {
            v4.o(a5, "prototype", "prototype");
        } catch(e8) {
        }
        const v9 = ++v4;
        try {
            C3.#m(a5, a5, v4, 1.0, v9);
        } catch(e11) {
        }
        return 0.0;
    }
    g = 0.0;
    e = "e";
    #f;
    static [C3] = "e";
}
const v12 = C3?.__lookupSetter__;
try { new v12(C3); } catch (e) {}
const v14 = new C3();
const v15 = new C3();
let v16 = new C3();
v16.g = v14;
let v19 = "GuBm";
let v20;
try { v20 = v19.split(1.0, v15); } catch (e) {}
788514224n + 788514224n;
function F25() {
    if (!new.target) { throw 'must be called with new'; }
    try { this.constructor(); } catch (e) {}
}
const v28 = new F25(v16);
const o29 = {
};
o29[v15] = v20;
v16 ^= v16;
Math.fround(v14);
const v34 = Math.asin(13);
Math.abs(1045469934);
v19--;
1045469934 * (13 + v19);
o29.e = v28;
const v39 = o29.c;
function F40(a42, a43, a44, a45) {
    if (!new.target) { throw 'must be called with new'; }
    const v46 = a42?.constructor;
    try { new v46(); } catch (e) {}
    a43.caller = v46;
}
try { new F40(v28, v39); } catch (e) {}
const v49 = ("b")[v39];
try { v49.getOwnPropertyNames(v34); } catch (e) {}
try {
    v28.toString = F25;
} catch(e51) {
}
