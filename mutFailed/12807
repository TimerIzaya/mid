const v1 = new Date();
class C2 extends Date {
    static a = Date;
    static #p(a4) {
        class C5 {
            static [this];
            a = a4;
        }
        new C5();
        new C5();
        new C5();
        return this;
    }
}
const v9 = new C2();
try { v9.getTimezoneOffset(); } catch (e) {}
const v11 = new C2();
const v12 = new C2();
try { v12.setFullYear(v9, v1, v9); } catch (e) {}
try { new Float32Array(v11, v11, v9); } catch (e) {}
const v17 = new Float32Array(9);
const v20 = new Uint16Array(715);
-7;
const v24 = new Int8Array(7);
v24[2];
function f26() {
    -9007199254740990 * -9007199254740990;
    const o39 = {
        ..."b",
        "b": -9007199254740990,
        ["b"]: "b",
        "a": -9007199254740990,
        o(a31, a32) {
            try { a32(a31, a32, "b"); } catch (e) {}
            [-504863.1885363821,-248378.80818527355,-147.11467188198264,-1.7039705769992093e+308] | -9007199254740990;
            function F36() {
                if (!new.target) { throw 'must be called with new'; }
            }
            class C38 extends F36 {
            }
            return -9007199254740990;
        },
        "h": "b",
    };
    return o39;
}
const o40 = {
};
o40.e = o40;
f26();
class C43 {
    static {
        this[Symbol.hasInstance];
    }
    #p() {
        try { this.p(undefined, this, this, this, this); } catch (e) {}
        return undefined;
    }
    static #a = undefined;
}
const v50 = new C43();
try { v50.propertyIsEnumerable(7); } catch (e) {}
const v53 = f26()?.constructor;
try { new v53(v20); } catch (e) {}
try { new Int16Array(715, Uint16Array, 715); } catch (e) {}
new Int16Array(1971);
new Int32Array(128);
const v63 = new Int16Array(195);
let v65 = 3375;
const v67 = new BigUint64Array(v65);
("c").toUpperCase();
const v70 = [-620100541,-64845,-268435456,-7,-268435456,1024,-536870912];
v70.length = v70;
const v72 = new Uint32Array(v70);
v72.BYTES_PER_ELEMENT;
try { Math.expm1(v17); } catch (e) {}
Math.expm1(v65, Math, v63);
let v77 = --v65;
v77--;
const v79 = Math.tan(v77);
v79 + v79;
const v81 = [-256,13351,5138,2,-4294967295,1000,268435440];
class C82 {
    constructor(a84, a85) {
        for (const v86 in this) {
        }
        Math.atan2(v81, -4294967297);
    }
}
class C89 extends C82 {
}
const v90 = new C89();
const v91 = v90?.constructor;
try { new v91(); } catch (e) {}
let [v93,,v94,...v95] = v67;
-v93;
v94 / v94;
try { v95.findIndex(C2); } catch (e) {}
var c = 255;
