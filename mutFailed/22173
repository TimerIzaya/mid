new BigInt64Array(3);
const v5 = Uint32Array.length;
v5 * v5;
const v7 = new Uint32Array(127);
14 & 14;
const v11 = new Float64Array(14);
try { new WeakSet(); } catch (e) {}
let v14 = new WeakSet();
const v15 = v14?.__defineGetter__;
try { new v15(14, v14); } catch (e) {}
let v17 = 268435456n;
const v21 = new Set();
function F22(a24, a25) {
    if (!new.target) { throw 'must be called with new'; }
    try { this.constructor(a24, WeakSet); } catch (e) {}
    try {
        this.d = a24;
    } catch(e27) {
        for (let [v28,v29] of a24) {
            try {
            } catch(e30) {
            }
        }
    }
    try {
    } catch(e31) {
    }
    const v32 = v21[this];
    try {
        new F22(v32);
    } catch(e34) {
    }
}
F22.name;
new F22();
const v37 = [65537,268435441,63298,-5,1235122603];
v37[1] = v37;
const v38 = [128,215394418];
v38[1] = v38;
const v39 = v38.entries();
function F40(a42, a43, a44, a45) {
    if (!new.target) { throw 'must be called with new'; }
}
let v46;
try { v46 = new F40(v21, v11, -4096n, BigInt64Array); } catch (e) {}
const v47 = new F22(v39, v46, v46);
const v49 = new F40();
const v50 = v49?.constructor;
try { new v50(-4096n, v47, v47, v21); } catch (e) {}
-65537 + -65537;
-13;
v38["PI"](..."PI", 2147483649, 2147483649, F40, ..."PI", ..."PI")?.[65535];
v17 ||= v17;
v14++;
const v64 = !v39;
3.5533037549385647 % v7;
const v66 = ~v64;
v66 * v66;
const v68 = v7 >>> v64;
v68 + v68;
Math.expm1(-48173);
const v74 = ("string").trimStart();
v39[3];
let v78;
try { v78 = v74(); } catch (e) {}
v37[v78] = v38;
const v81 = ~0;
v81 / v81;
const v85 = v47.__proto__?.constructor;
try { new v85(v17, -35417, v85, v15, Math); } catch (e) {}
const v87 = -35417 - -35417;
v87 * v87;
